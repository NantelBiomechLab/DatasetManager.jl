var documenterSearchIndex = {"docs":
[{"location":"concepts/conditions/#TrialConditions","page":"Trial Conditions","title":"TrialConditions","text":"","category":"section"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"A TrialConditions is a type [Julia] or class [MATLAB] that describes the names and possible values for the experimental conditions (aka factors) and other characteristics (e.g. subject ID, etc) which are needed to describe and recognize multiple sources as being associated with a single, unique Trial.","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"A correctly specified TrialConditions allows the findtrials function to search DataSubsets for suitable sources and match/group them into a Trial. Datasets may have a complex design and a complex organization (including typos, inconsistent naming of the same level in a condition, etc). Therefore TrialConditions is designed to be capable of describing such complexity.","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"tip: Terms\ncondition:The name of an experimental condition or factorlabel:A value of a conditionExample: \"control\" is a valid label for the condition \"group\"","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"compat: Current Assumptions/Limitations\nAll conditions (needed to uniquely describe a trial) are present in the absolute path of a source\nConditions have a consistent order (e.g. condition session is always after group)","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"The simplest datasets can be described by listing all valid labels for each condition. This might look like:","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"using DatasetManager","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"labels = Dict(\n    :subject => [\"1\", \"2\", \"3\", \"4\", \"5\"],\n    :arms => [\"held\", \"norm\", \"active\"]\n);\nconds = TrialConditions((:subject,:arms), labels);","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"labels.subject(1).to = '1';\nlabels.subject(2).to = '2';\nlabels.subject(3).to = '3';\nlabels.subject(4).to = '4';\nlabels.subject(5).to = '5';\nlabels.arms(1).to = 'held';\nlabels.arms(2).to = 'norm';\nlabels.arms(3).to = 'active';\n\nconds = TrialConditions.generate({'subject','arms'}, labels);","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"But many datasets aren't that simple or organized so perfectly. Suppose some trials had capitalized first letters for the arms conditions. The original labels would not match, and those trials would be ignored. We can explicitly add capitalized options:","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"using DatasetManager","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"labels = Dict(\n    :subject => [\"1\", \"2\", \"3\", \"4\", \"5\"],\n    :arms => [\"Held\" => \"held\", \"Norm\" => \"norm\", \"Active\" => \"active\"]\n);\nconds = TrialConditions((:subject,:arms), labels);","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"labels.subject(1).to = '1';\nlabels.subject(2).to = '2';\nlabels.subject(3).to = '3';\nlabels.subject(4).to = '4';\nlabels.subject(5).to = '5';\nlabels.arms(1).from = 'Held';\nlabels.arms(1).to = 'held';\nlabels.arms(2).from = 'Norm';\nlabels.arms(2).to = 'norm';\nlabels.arms(3).from = 'Active';\nlabels.arms(3).to = 'active';\n\nconds = TrialConditions.generate({'subject','arms'}, labels);","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"We now are matching all hypothetical trials. However, the capitalized conditions will not be recognized as the same actual levels as the corresponding lowercase levels. One solution is to define conversions for non-canonical (e.g. capitalized, known typos, etc) levels.","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"using DatasetManager","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"labels = Dict(\n    :subject => [\"1\", \"2\", \"3\", \"4\", \"5\"],\n    :arms => [\"Held\" => \"held\", \"Norm\" => \"norm\", \"Active\" => \"active\"]\n);\nconds = TrialConditions((:subject,:arms), labels);","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"labels.subject(1).to = '1';\nlabels.subject(2).to = '2';\nlabels.subject(3).to = '3';\nlabels.subject(4).to = '4';\nlabels.subject(5).to = '5';\nlabels.arms(1).from = 'Held';\nlabels.arms(1).to = 'held';\nlabels.arms(2).from = 'Norm';\nlabels.arms(2).to = 'norm';\nlabels.arms(3).from = 'Active';\nlabels.arms(3).to = 'active';\n\nconds = TrialConditions.generate({'subject','arms'}, labels);","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/conditions/","page":"Trial Conditions","title":"Trial Conditions","text":"Now all the capitalized conditions will be converted to lowercase.","category":"page"},{"location":"examples/datasets-examples/#Describing-datasets","page":"Describing datasets","title":"Describing datasets","text":"","category":"section"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"Below are two examples of datasets with different organizations and issues which demonstrate the capabilities of DatasetManager.","category":"page"},{"location":"examples/datasets-examples/#Well-organized-dataset-with-minimal-issues","page":"Describing datasets","title":"Well organized dataset with minimal issues","text":"","category":"section"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"Consider a dataset organized as follows:","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"ðŸ“‚ genpath\nâ”œ ðŸ“‚ Visual3D\nâ”‚ â”œ ðŸ“‚ Subject 1\nâ”‚ â”‚ â”œ ðŸ“‚ export\nâ”‚ â”‚ â”‚ â”” ðŸ“‚ park\nâ”‚ â”‚ â”‚   â”œ park-none.mat\nâ”‚ â”‚ â”‚   â”œ park-norm.mat\nâ”‚ â”‚ â”‚   â”” park-excess.mat\nâ”‚ â”‚ â”” ðŸ“‚ import\nâ”‚ â”œ ðŸ“‚ Subject 2\nâ”‚ â”Š\nâ”‚\nâ”” ðŸ“‚ DFlow\n  â”œ ðŸ“‚ Subject 1\n  â”‚ â”œ park-none.csv\n  â”‚ â”œ park-norm.csv\n  â”‚ â”œ park-excess.csv\n  â”‚ â”Š\n  â”œ ðŸ“‚ Subject 2\n  â”Š\n\nðŸ“‚ rawpath\nâ”œ ðŸ“‚ Subject 1\nâ”‚ â”” ðŸ“‚ _\nâ”‚   â”œ park-none.c3d\nâ”‚   â”œ park-norm.c3d\nâ”‚   â”œ park-excess.c3d\nâ”‚   â”Š\nâ”œ ðŸ“‚ Subject 2\nâ”Š","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"The dataset is organized into 3 separate folders, but all the trials use the same naming scheme between the different folders. Therefore, we can group the data into 3 different data subsets (genpath/Visual3D, genpath/DFlow, and rawpath) for this analysis based on their location and filetype. Each DataSubset gets a name, a source type, a parent directory, and a glob which describes the structure and location, and possibly more (eg extension), of the files specified by the DataSubset.","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details open=\"\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"genpath = \"path/to/one/subset\"\ndflowpath = \"path/to/another/subset\"\n\nparksubsets = [\n    DataSubset(\"visual3d\", V3DExportSource, joinpath(genpath, \"Visual3D\"), \"Subject [0-9]*/export/park/park-*.mat\"),\n    DataSubset(\"dflow\", DFlowSource, joinpath(genpath, \"DFlow\"), \"Subject [0-9]*/park-*.csv\"),\n    DataSubset(\"vicon\", C3DSource, rawpath, \"Subject [0-9]*/_/park-*.c3d\")\n]","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details>\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"genpath = 'path/to/one/subset'\ndflowpath = 'path/to/another/subset'\n\nparksubsets = [\n    DataSubset('visual3d', 'V3DExportSource', fullfile(genpath, 'Visual3D/Subject */export/park/park-*.mat')),\n    DataSubset('dflow', 'DFlowSource', fullfile(genpath, 'DFlow/Subject */park-*.csv')),\n    DataSubset('vicon', 'C3DSource', fullfile(rawpath, 'Subject */_/park-*.c3d'))\n]","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</p>\n<div class=\"admonition-body\">","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"info: Info\nThe MATLAB globbing syntax only supports asterisks. More info here.","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</div>\n</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"This dataset only has one condition (aka 'factor' in statistical contexts) with three levels. The dataset was created with different terms for 2 of the levels, and we also wish to improve the naming of some of the levels. Any trial with \"none\" in the path will be recognized as a \"held\" trial. If a trial happens to already have the new terminology (\"held\"), it will be recognized as a \"held\" trial. The \"norm\" condition is left unchanged, and will only match trials with \"norm\" in the path.","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details open=\"\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"levels = Dict(:arms => [\"none\" => \"held\", \"norm\", \"excess\" => \"active\"])\nparkconds = TrialConditions((:arms,), levels)","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details>\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"levels.arms(1).from = 'none'\nlevels.arms(1).to = 'held'\nlevels.arms(2).to = 'norm'\nlevels.arms(3).from = 'excess'\nlevels.arms(3).to = 'active'\n\nparkconds = TrialConditions.generate({'arms'}, levels)\n% alternately:\nparkconds = TrialConditions.generate(fieldnames(levels), levels)","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"The findtrials function will search every DataSubset for trials which match the TrialConditions:","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details open=\"\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"# Read all perturbations\nparktrials = findtrials(parksubsets, parkconds)","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details>\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"parktrials = DataSet.findtrials(parksubsets, parkconds)","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"tip: Dealing with duplicate or unwanted files\nIn some cases, there are duplicate (e.g. a trial was redone due to technical difficulties, etc) or unwanted (e.g. corrupted data, etc) files that will match the same set of conditions in a particular DataSubset, and the findtrials function will be unable to determine which file should be used for that DataSubset source. Suppose the first of attempt for a trial, \"Subject 01/_/park-norm.c3d\" had an issue, and it was repeated with a '-02' added after the trial name (\"Subject 01/_/park-norm-02.c3d\").julia> parktrials = findtrials(parksubsets, parkconds)\n\nERROR: DuplicateSourceError: Found \"vicon\" source file \"â€¦/Subject 01/_/park-norm-02.c3d\" for\n Trial(1, \"park-norm\", Dict{Symbol,Any}(:arms => \"norm\"), 3 sources) which already has\n a \"vicon\" source at \"â€¦/Subject 01/_/park-norm.c3d\"\nStacktrace:\n [1] findtrials(::Array{DataSubset,1}, ::TrialConditions; I::Type{T} where T, subject_fmt::Regex, ignorefiles::Array{String,1}, defaultconds::Nothing) at /home/user/.julia/dev/DatasetManager/src/trial.jl:232\n [2] top-level scope at REPL[7]:1This DuplicateSourceError alerts you that, for Trial(1, \"park-norm\", Dict{Symbol,Any}(:arms => \"norm\")) there are conflicting files for the \"vicon\" source, and gives you the names of the two files.  The solution is to add any duplicate or unwanted files to the ignorefiles keyword argument (or the 'IgnoreFiles' optional argument in MATLAB).Julia:# Read all perturbations\nparktrials = findtrials(parksubsets, parkconds; ignorefiles=[\n    joinpath(rawpath, \"Subject 01/_/park-norm-01.c3d\")\n])MATLAB:parktrials = DataSet.findtrials(parksubsets, parkconds, 'IgnoreFiles', { ...\n    fullfile(rawpath, 'Subject 01/_/park-norm-01.c3d')\n})","category":"page"},{"location":"examples/datasets-examples/#Dataset-with-different-naming-schemes","page":"Describing datasets","title":"Dataset with different naming schemes","text":"","category":"section"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"Consider a different dataset, organized as follows:","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"ðŸ“‚ v3dpath\nâ”œ ðŸ“‚ Subject 1\nâ”‚ â”œ ðŸ“‚ Export\nâ”‚ â”‚ â”œ 20181204_1400_NORMS_TR03.mat\nâ”‚ â”‚ â”œ 20181204_1400_NORMC_TR03.mat\nâ”‚ â”‚ â”œ 20181204_1400_NORM_PARK_TR03.mat\nâ”‚ â”‚ â”Š\nâ”‚ â”” ðŸ“‚ import\nâ”œ ðŸ“‚ Subject 2\nâ”‚ â”” ðŸ“‚ Export\nâ”‚   â”œ norm-singletask.mat\nâ”‚   â”œ Norm-dualtask.mat\nâ”‚   â”œ park-norm.mat\nâ”‚   â”Š\nâ”Š\n\nðŸ“‚ dflowpath\nâ”œ ðŸ“‚ N01\nâ”‚ â”œ 20181204_1400_1448_AS_BA_NP_N01_TR01.txt\nâ”‚ â”œ 20181204_1400_1501_AS_CO_NP_N01_TR01.txt\nâ”‚ â”œ 20181204_1400_1646_NA_TR_NP_N05_TR01.txt\nâ”‚ â”Š\nâ”œ ðŸ“‚ N02\nâ”Š","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"This analysis only needs 2 DataSubsets:","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details open=\"\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"v3dpath = \"path/to/one/subset\"\ndflowpath = \"path/to/another/subset\"\n\nparkdatafiles = [\n    DataSubset(\"visual3d\", V3DExportSource, v3dpath, \"Subject [0-9]*/Export/*.mat\"),\n    DataSubset(\"dflow\", RawDFlowPDSource, dflowpath, \"N[0-9]*/*.txt\")\n]","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details>\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"v3dpath = 'path/to/one/subset'\ndflowpath = 'path/to/another/subset'\n\nparkdatafiles = [\n    DataSubset('visual3d', 'V3DExportSource', fullfile(v3dpath, 'Subject */Export/*.mat')),\n    DataSubset('dflow', 'RawDFlowPDSource', fullfile(dflowpath, 'N*/*.txt'))\n]","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"This dataset has several issues which make the level filters more complex and require the use of Regex to properly find the conditions.","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"The \"visual3d\" subset isn't completely consistent in the naming. For example \"Norm\" was sometimes used instead of \"norm\", and \"dual\" was sometimes used instead of\n\"dualtask\".  The \"dflow\" subset used a completely different trial naming scheme. \"AS\" was used instead of \"norm\", \"BA\" instead of \"singletask\", etc.","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"Such conversions can be dealt with simply. However, a slightly more complex issue is that the \"singletask\" condition in the \"visual3d\" subset is denoted by an \"S\" following the \"arms\" factor. Just matching an \"S\" could match either the \"S\" in \"Subject\" or in \"RS\"; we need to only match an \"S\" that follows the \"arms\" factor, which can be specified by a positive lookbehind group in Regex, like this: \"(?<=NONE|NORM)S\". A similar Regex can be used to deal with the \"C\" for \"dualtask\".","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"A similar technique can be used to find the \"TR\" denoting the \"park\" condition, by using lookbehind and lookahead Regex groups. The naming scheme for the \"dflow\" subset contains \"TR\" for every trial (\"20181204_1400_1646_AS_TR_NP_N05_TR01.txt\"), unrelated to the \"park\" condition. However, we notice that the \"TR\" denoting the \"park\" condition has underscores on either side; based on that observation, we can write a Regex for these requirements as \"(?<=_)TR(?=_)\".","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details open=\"\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"labels = Dict(:arms => [[\"NONE\", \"NA\"] => \"held\", [\"AS\", \"Norm\", \"NORM\"] => \"norm\"],\n              :kind => [[\"(?<=NONE|NORM|held|norm)S\", \"BA\", \"single\"] => \"singletask\",\n                        [\"(?<=NONE|NORM|norm|held)C\", \"CO\",, \"CP\", \"dual\"] => \"dualtask\",\n                        \"PO\" => \"pert\", [\"PARK\", \"(?<=_)TR(?=_)\"] => \"park\"],\n              :pert_side => [\"R(?=[ST]|slip|trip)\" => \"right\", \"L(?=[ST]|slip|trip)\" => \"left\"],\n              :pert_type => [\"NP\" => \"steadystate\", \"(?<=[RL]|right|left)T\" => \"trip\", \"(?<=[RL]|right|left)S\" => \"slip\"])\nconds = TrialConditions((:arms,:kind,:pert_side,:pert_type), labels; required=(:arms,:kind))","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details>\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"labels.arms(1).from = {'NONE', 'NA'};\nlabels.arms(1).to = 'held';\nlabels.arms(2).from = {'AS', 'Norm', 'NORM'};\nlabels.arms(2).to = 'norm';\n\nlabels.kind(1).from = {'(?<=NONE|NORM|held|norm)S', 'BA', 'single'};\nlabels.kind(1).to = 'singletask';\nlabels.kind(2).from = {'(?<=NONE|NORM|norm|held)C', 'CO', 'CP', 'dual'};\nlabels.kind(2).to = 'dualtask';\nlabels.kind(3).from = 'PO';\nlabels.kind(3).to = 'pert';\nlabels.kind(4).from = {'park', '(?<=_)TR(?=_)'};\nlabels.kind(4).to = 'park' ;\n\nlabels.pert_side(1).from = 'R(?=[ST]|slip|trip)';\nlabels.pert_side(1).to = 'right';\nlabels.pert_side(2).from = 'L(?=[ST]|slip|trip)';\nlabels.pert_side(2).to = 'left';\n\nlabels.pert_type(1).from = 'NP';\nlabels.pert_type(1).to = 'steadystate';\nlabels.pert_type(2).from = '(?<=[RL]|right|left)T';\nlabels.pert_type(2).to = 'trip';\nlabels.pert_type(3).from = '(?<=[RL]|right|left)S';\nlabels.pert_type(3).to = 'slip';\n\nconds = TrialConditions.generate({'arms','kind','pert_side','pert_type'}, labels, 'Required', {'arms', 'kind'})","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"note: Note\nThese TrialConditions also include the optional factors of pert_side and pert_type. When the required ('Required' in MATLAB) keyword arg is not specified, it is assumed that all factors are required. In this case, the \"visual3d\" subset only included the pert_side and pert_type levels for trials that included a perturbation.","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"As always, the findtrials function will locate trials and sources within each subset which match the given conditions.","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details open=\"\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"# Read all perturbations\nparktrials = findtrials(parkdatafiles, conds;\n    subject_fmt=r\"(?<=Subject |N)(?<subject>\\d+)\", ignorefiles=[\n        joinpath(dflowpath, \"N02/20181206_1500_1554_NA_BA_NP_N02_TR01.txt\"),\n        joinpath(dflowpath, \"N02/20181206_1500_1657_AS_CP_RT_N02_TR01.txt\"),\n        â‹®\n        joinpath(dflowpath, \"N020/20190509_1000_1113_NA_CP_RS_N020_TR01.txt\"),\n        joinpath(dflowpath, \"N020/20190509_1000_1153_AS_PO_LT_N020_TR01.txt\")\n    ], defaultconds=Dict(:pert_type => \"steadystate\"))","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details>\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"% Read all perturbations\nparktrials = DataSet.findtrials(parkdatafiles, conds, ...\n    'SubjectFormat', '(?<=Subject |N)(?<subject>\\d+)', 'IgnoreFiles', { ...\n        fullfile(dflowpath, 'N02/20181206_1500_1554_NA_BA_NP_N02_TR01.txt'), ...\n        fullfile(dflowpath, 'N02/20181206_1500_1657_AS_CP_RT_N02_TR01.txt'), ...\n        â‹®\n        fullfile(dflowpath, 'N020/20190509_1000_1113_NA_CP_RS_N020_TR01.txt'), ...\n        fullfile(dflowpath, 'N020/20190509_1000_1153_AS_PO_LT_N020_TR01.txt') ...\n    }, 'DefaultConditions', containers.Map('pert_type', 'steadystate'))","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"tip: Keyword arg: `subject_fmt` (`'SubjectFormat'` in MATLAB)\nThe subject_fmt Regex has been modified here to match the subject id between the different naming schemes of the two DataSubsets.","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"tip: Keyword arg: `defaultconds` (`'DefaultConditions'` in MATLAB)\nThe defaultconds Dict can be particularly useful when some conditions are optional, and therefore may not exist in the file path, but are needed or desired in the Trials.","category":"page"},{"location":"concepts/sources/#Sources","page":"Sources","title":"Sources","text":"","category":"section"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"A Source is a type [Julia] or class [MATLAB] that refers to the location of a source of data (typically a path to a file). DatasetManager normally assumes that sources contain time-series data (e.g. in readsegment, however this is not a requirement.","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"Datasets often have more than one kind of source (e.g. if multiple systems were used to collect different kinds of data, such as EMG and motion capture). These different kinds of data require special code to load them for analysis. Furthermore, even within the same file extension (e.g. .csv), files can have different data organization (e.g. the number of lines in the header, type of data in columns, etc) which require special handling. These differences make using the file extension too inaccurate for choosing which function is appropriate for reading a particular file.","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"By defining custom readsource functions [Julia/MATLAB], we can ensure that the data in any source can be correctly accessed using a single standard function.","category":"page"},{"location":"concepts/sources/#Example-source-definitions","page":"Sources","title":"Example source definitions","text":"","category":"section"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"OpenSim is an open-source software for neuromusculoskeletal modeling, simulation, and analysis. Motion data is stored in tab-separated files with the extension .mot.","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"We'll define a singleton type to dispatch on:","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"struct OSimMotion; end","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"and then define a readsource method for Source{OSimMotion}:","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"using CSV, DataFrames\nfunction DatasetManager.readsource(src::Source{OSimMotion})\n    data = CSV.File(sourcepath(src); header=11, delim='\\t') |> DataFrame\n\n    return data\nend","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"We'll define a class inheriting from the Source class, and use the OpenSim MATLAB bindings to read the motion file:","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"classdef OSimMotion < Source\n    methods\n        function data = readsource(obj, varargin)\n            import org.opensim.modeling.*\n            % TimeSeriesTable from the OpenSim MATLAB bindings can read standard OpenSim\n            % file types\n            data = TimeSeriesTable(obj.path);\n        end\n    end\nend","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"These are the minimal implementations needed to define a Source for reading OpenSim motion files, and could be used like this:","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"readsource(Source{OSimMotion}(\"/path/to/mot\"))","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"readsource(OSimMotion('/path/to/mot'))","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"info: Info\nTheoretically, Sources do not need to be locally stored or individual files (e.g. a source could be stored in a database and could be defined to include a SQL query to retrieve the particular referenced data from the server). However at the time of writing, all datasets that have been used with DatasetManager have been locally stored in sources referring to separate, individual files.","category":"page"},{"location":"concepts/sources/#Adding-a-readsegment-method","page":"Sources","title":"Adding a readsegment method","text":"","category":"section"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"A Segment [Julia/MATLAB] refers to a segment of time in a time-series source. A readsegment method should be functionally equivalent to readsource(segment.source)[starttime:finishtime]. Here is an example for our OSimMotion source:","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"function DatasetManager.readsegment(seg::Segment{Source{OSimMotion}})\n    data = readsource(seg.source)\n    if !isnothing(seg.start)\n        starti = searchsortedfirst(data[!, \"time\"], seg.start)\n    else\n        starti = firstindex(data, 1)\n    end\n\n    if !isnothing(seg.finish)\n        lasti = searchsortedlast(data[!, \"time\"], seg.finish)\n    else\n        lasti = lastindex(data, 1)\n    end\n\n    return data[starti:lasti, :]\nend","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"% define in methods of the classdef for OSimMotion\nfunction data = readsegment(seg)\n    data = readsource(seg.source);\n    % the trimFrom function is a part of OpenSim's MATLAB bindings\n    data.trimFrom(seg.start, seg.finish);\nend","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/sources/#Required-sources-and-automatically-generating-sources","page":"Sources","title":"Required sources and automatically generating sources","text":"","category":"section"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"Sometimes a source can be generated from another source (or sources). This could be a simple file conversion (e.g. .c3d to .trc), or something more involved, such as running inverse kinematics in OpenSim. The requiresource!/requiresource [MATLAB] interface will check if a source exists, and attempt to generate it if not, and throw an error if it is unable to generate the source.","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"To support generating a source, a dependencies method [Julia/MATLAB] must be defined to declare what other sources the source of interest depends on to be generated.","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"Define the dependencies:","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"DatasetManager.dependencies(::Source{OSimMotion}) = (Source{OSimIKSetup},)","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"Then we define a generatesource method:","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"function DatasetManager.generatesource(trial, src::Source{OSimMotion}, deps)\n    iksetup = getsource(trial, only(filter(x-> Source{OSimIKSetup} === x, deps)))\n    run(`opensim-cmd run-tool $(sourcepath(iksetup))`)\n\n    return src\nend","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"Define the dependencies:","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"% define in methods of the classdef for OSimMotion\nfunction deps = dependencies(obj)\n    deps = {OSimIKSetup()};\nend","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"Then we define a generatesource method:","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"% define in methods of the classdef for OSimMotion\nfunction src = generatesource(obj, trial, deps)\n    status = system(['opensim-cmd run-tool ' sourcepath(obj)]);\n    assert(status == 0)\n\n    src = obj;\nend","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"With those two methods now defined, the requiresource! function can be called, which will generate the OSimMotion source if it is not already present:","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"requiresource!(trial, Source{OSimMotion})","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"requiresource(trial, OSimMotion)","category":"page"},{"location":"concepts/sources/","page":"Sources","title":"Sources","text":"The preceding Julia/MATLAB examples are simplified for clarity. Complete working examples in Julia and MATLAB for an OpenSim motion file source and other sources can be found at LabDataSources.jl and LabDataSources, respectively.","category":"page"},{"location":"matlab-reference/#MATLAB-reference","page":"MATLAB Reference","title":"MATLAB reference","text":"","category":"section"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"TrialConditions\" class=\"docstring-binding\" href=\"#TrialConditions\"><code>TrialConditions</code></a>\n         â€”\n        <span class=\"docstring-category\">Class</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Defines the names and levels of experimental conditions.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"See also TrialConditions.generate","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/TrialConditions.m#L1-L4\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"TrialConditions.generate\" class=\"docstring-binding\" href=\"#TrialConditions.generate\"><code>TrialConditions.generate</code></a>\n         â€”\n        <span class=\"docstring-category\">Function</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"trialconds = generate(conditions, labels)\ntrialconds = generate(conditions, labels, Name, Value)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Define the names of experimental conditions (aka factors) and the possible labels within each condition. Conditions are determined from the absolute path of potential sources.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Input arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"conditions is a cell array of condition names (eg {'medication', 'dose'}) in the order they must appear in the file paths of trial sources\nlabels is a struct with a field for each condition name (eg isfield(labels, 'medication')). Each condition field must have 'to' and 'from' fields which contain the final names and all the name possibilities, respectively. The 'from' field is optional if the terminology in the filenames is the desired terminology.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Name-value arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"'Required' (defaults to all conditions): The conditions which every trial must have (in the case of some trials having optional/additional conditions).\n'Separator' (defaults to '[_-]'): The character separating condition labels","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Examples","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"labels.session(1).to = '\\d';\nlabels.stim(1).to = 'stim';\nlabels.stim(2).to = 'placebo';\n% or equivalently:\nlabels.session.to = '\\d';\nlabels.stim = struct('to', { 'stim'; 'placebo' });\n\nconds = TrialConditions.generate({'session';'stim'}, labels)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/TrialConditions.m#L25-L59\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"DataSubset\" class=\"docstring-binding\" href=\"#DataSubset\"><code>DataSubset</code></a>\n         â€”\n        <span class=\"docstring-category\">Class</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"subset = DataSubset(name, source, pattern)\nsubset = DataSubset(name, source, pattern, ext)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Describes a subset of source data files found within a folder dir which match pattern.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Input arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"name: The name of the DataSubset that will be used in findtrials as the source name in a Trial.\nsource: The Source type of all files described by this subset\npattern: The pattern (using glob syntax) that defines where sources in this subset are stored on disk.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Examples","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"subsets = [\n    DataSubset('events', @GaitEvents, '/path/to/events/Subject */*.csv')\n]","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"See also Source, TrialConditions, Trial.findtrials","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/DataSubset.m#L1-L23\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"Trial\" class=\"docstring-binding\" href=\"#Trial\"><code>Trial</code></a>\n         â€”\n        <span class=\"docstring-category\">Class</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"trial = Trial(subject, name, conditions, sources)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Characterizes a single instance of data collected from a specific subject. The Trial has a name, and may have on or more conditions which describe experimental conditions and/or subject specific charateristics which are relevant to subsequent analyses. A Trial may have one or more complementary sources of data (e.g. simultaneous recordings from separate equipment stored in separate files, supplementary data for a primary data source, etc).","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Input arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"subject: The unique identifier (ID) char vector of the subject/participant in the trial\nname: The trial name (a char vector)\nconditions: A struct containing a field for every condition\nsources: A struct containing a field for every source","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Examples","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"trial = Trial('1', 'baseline', struct('group', 'control', 'session', 2), struct())","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/Trial.m#L1-L22\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"Trial.findtrials\" class=\"docstring-binding\" href=\"#Trial.findtrials\"><code>Trial.findtrials</code></a>\n         â€”\n        <span class=\"docstring-category\">Function</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"trials = findtrials(subsets, conditions)\ntrials = findtrials(subsets, conditions, Name, Value)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Find all the trials matching conditions which can be found in subsets.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Input arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"subsets: The DataSubsets to use when finding sources\nconditions: The TrialConditions for these sources/trials","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Name-Value arguments:","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"'SubjectFormat': The regex pattern used to match the trial's subject ID. (defaults to 'Subject (?<subject>\\d+)'`).\n'IgnoreFiles': A list of files to ignore that are in any of the subsets, given in the form   of an absolute path.\n'DefaultConditions': Default conditions to set when a given condition is not matched. Defaults can be given for required conditions. If a condition is not required, has no default, and is not matched, it will not be included as a condition for a source.\n'Debug': Show files that did not match all the required conditions (default is false)\n'Verbose': Also show files that did match all required conditions. Has no effect is 'Debug' is set to false.\n'MaxLog': The maximum number of files per subset to show when 'Debug' is set to true","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"See also Trial, DataSubset, TrialConditions.generate","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/Trial.m#L171-L199\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"Trial.summarize\" class=\"docstring-binding\" href=\"#Trial.summarize\"><code>Trial.summarize</code></a>\n         â€”\n        <span class=\"docstring-category\">Function</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"summarize(trials)\nsummarize(trials, Name, Value)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Summarize an array of trials","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Name-Value arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"'Verbosity': The maximum number of unique level combinations to show","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/Trial.m#L339-L347\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"Trial.analyzetrials\" class=\"docstring-binding\" href=\"#Trial.analyzetrials\"><code>Trial.analyzetrials</code></a>\n         â€”\n        <span class=\"docstring-category\">Function</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"results = analyzetrials(func, trials)\nresults = analyzetrials(func, trials, Name, Value)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Evaluate a function on each trial in an array of trials","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"If the function errors for a particular trial, an emtpy result will be returned for that trial, and a warning will be printed that includes the problematic trial and the error that was thrown. However, the rest of the trials in the array will continue to be analyzed with the given function.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Input arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"func: A handle to a function, e.g. @<function name>\ntrials: An array of Trials, typically generated by findtrials","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Name-Value arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"'Parallel': Use multiple threads/processes to evaluate the function on multiple trials at once. Can result in a faster analysis, but requires the \"Parallel Computing Toolbox\"","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"See also Trial.findtrials","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/Trial.m#L458-L480\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"SegmentResult.stack\" class=\"docstring-binding\" href=\"#SegmentResult.stack\"><code>SegmentResult.stack</code></a>\n         â€”\n        <span class=\"docstring-category\">Function</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"tbl = stack(segres)\ntbl = stack(segres, Name, Value)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Stack an array of SegmentResults into a long form table","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Name-Value arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"'Conditions': The conditions to include in the table (default is all conditions present in any trials/segments). Used to remove \"conditions\" which are not experimental (i.e. needed for grouping/reducing in subsequent statistics)\n'Variables': The variables to include in the table (default is all variables present in any trials/segments).","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/SegmentResult.m#L64-L77\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"write_results\" class=\"docstring-binding\" href=\"#write_results\"><code>write_results</code></a>\n         â€”\n        <span class=\"docstring-category\">Function</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"write_results(filename, tbl, conds)\nwrite_results(filename, tbl, conds, Name, Value)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Write the results in tbl to file at filename, including only the conditions given by conds.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Input arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"filename: The path to write the results to\ntbl: The table containing results. Must already be in 'long' form (default from stack)\nconds: A cell array listing the subset of conditions which are to be included/written to file","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Name-Value arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"'Variables': A cell array listing the subset of variables to be written to file\n'Format': Must be either 'wide' or 'long', defaults to 'wide'. Determines the shape of the written results. (Needs to be 'wide' for some common stats in SPSS, e.g. ANOVA.)\n'Archive': A logical value controlling whether a file already existing at filename should be archived to [filename '.bak'] before writing the new results to filename.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"See also SegmentResult.stack","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/write_results.m#L1-L25\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"Source\" class=\"docstring-binding\" href=\"#Source\"><code>Source</code></a>\n         â€”\n        <span class=\"docstring-category\">Class</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"src = Source(path)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"A type representing a source of data in a particular file format","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Input arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"path: The absolute path to the source file","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Examples","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"src = Source('/path/to/source/file')","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Creating custom sources","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"All subtypes of Source must:","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"have a path field\nhave at least these two constructors:\nempty constructor\nsingle argument constructor accepting a char vector of an absolute path","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Source subtypes should:","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"have a Source.readsource method","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Source subtypes may implement these additional methods to improve user experience and/or enable additional funcitonality:","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Source.readsegment\nSource.generatesource (if enabling requiresource! generation)\nSource.dependencies (if defining a generatesource method)\nSource.srcext\nSource.srcname_default","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/Source.m#L1-L36\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"Source.readsource\" class=\"docstring-binding\" href=\"#Source.readsource\"><code>Source.readsource</code></a>\n         â€”\n        <span class=\"docstring-category\">Function</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"data = readsource(src)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Read the source data from file.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/Source.m#L106-L110\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"Trial.requiresource\" class=\"docstring-binding\" href=\"#Trial.requiresource\"><code>Trial.requiresource</code></a>\n         â€”\n        <span class=\"docstring-category\">Function</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"requiresource(trial, src)\nrequiresource(trial, src, Name, Value)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Require a source to exist for a trial, attempt to generate the source if missing and possible to generate.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Name-Value arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"'Name': The name to use if the src is missing and needs to be generated. Defaults to the srcname_default(src).\n'Force': (Re)generate the src, even if it already exists.\n'Dependencies': The sources that src depends on to be generated. Defaults to dependencies(src), which will be empty if the src class has not defined a dependencies method.\nAny remaining unmatched name-value arguments will be passed on to generatesource (if called).","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Examples","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"requiresource(trial, GaitEvents(), 'Dependencies', {C3DSource()})","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/Trial.m#L99-L121\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"Source.generatesource\" class=\"docstring-binding\" href=\"#Source.generatesource\"><code>Source.generatesource</code></a>\n         â€”\n        <span class=\"docstring-category\">Function</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"newsrc = generatesource(src, trial, deps)\nnewsrc = generatesource(src, trial, deps, Name, Value)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Generate a source src for trial using the dependent sources deps. Returns a source of the same class as src, but is not required to be exactly equal to src (i.e. a different src.path).","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Input arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"src: A source that may or may not exist yet (e.g. if 'Force' was set to true in requiresource).\ntrial: The trial that src/newsrc is being generated for/from.\ndeps: The sources that src depends on to be generated (i.e. sources which contain data which is used to generate the data comprising newsrc)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Name-Value arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Any name-value arguments will be specific to a particular Source class subtype. N.B.: generatesource will normally be called by requiresource, which uses name-value arguments 'Name', 'Force', and 'Dependencies'. These names are functionally reserved (i.e. not available for use in generatesource methods), as they will not be passed on to generatesource by requiresource.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/Source.m#L116-L139\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"Source.dependencies\" class=\"docstring-binding\" href=\"#Source.dependencies\"><code>Source.dependencies</code></a>\n         â€”\n        <span class=\"docstring-category\">Function</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"deps = dependencies(src)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Get the sources that src depends on to be generated with generatesource. By default sources are assumed not to be automatically generatable, therefore dependencies returns false unless a dependencies method has been created for a specific class subtyping Source.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/Source.m#L145-L151\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"Source.srcext\" class=\"docstring-binding\" href=\"#Source.srcext\"><code>Source.srcext</code></a>\n         â€”\n        <span class=\"docstring-category\">Function</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"ext = srcext(src)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Get the file extension for a source.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Input arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"src: Can be the class of a source subtype or an instance of a source. If src is a class, the default extension for that src < Source class will be returned; if src is an instance of a source, then the actual extension for that src will be returned, regardless of whether it matches the default extension for that class or not.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Examples","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"% assuming the existence of a class `GaitEvents` which subtypes `Source`\nsrc = GaitEvents('/path/to/file.tsv')\next = srcext(GaitEvents) % == '.csv'\next = srcext(src) % == '.tsv'","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Implementation notes","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"When defining a method for a custom class subtyping Source, the period should be included in the extension.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Example implementation","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"function ext = srcext(obj)\n% Calling the default `srcext` method for `Source` will return the actual\n% extension for `< Source` instances\n    ext = srcext@Source(obj);\n\n    if isempty(ext)\n        ext = '.ext';\n    end\nend","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/Source.m#L58-L97\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"Source.srcname_default\" class=\"docstring-binding\" href=\"#Source.srcname_default\"><code>Source.srcname_default</code></a>\n         â€”\n        <span class=\"docstring-category\">Function</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"name = srcname_default(src)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Get the default name for a source of a given < Source class","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/Source.m#L156-L159\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"Segment\" class=\"docstring-binding\" href=\"#Segment\"><code>Segment</code></a>\n         â€”\n        <span class=\"docstring-category\">Class</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"seg = Segment(trial, source)\nseg = Segment(trial, source, Name, Value)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Describes a segment of time in a source for a trial, optionally with additional conditions specific to that segment of time. The conditions for the whole trial will be combined with any conditions specific to the segment (so that all conditions applicable to that segment of time will be available in one spot).","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Input arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"source: Can be an instance of a Source class subtype, or the name of a source known/expected to be present in trial.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Name-Value arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"'Start': The beginning time of the segment\n'Finish': The ending time of the segment\n'Conditions': A struct containing any additional conditions for that segment.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/Segment.m#L1-L19\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"Segment.readsegment\" class=\"docstring-binding\" href=\"#Segment.readsegment\"><code>Segment.readsegment</code></a>\n         â€”\n        <span class=\"docstring-category\">Function</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"data = readsegment(seg)\ndata = readsegment(seg, Name, Value)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Read the segment of time from the source of seg. Name-value arguments (besides 'Start' and 'Finish', which are reserved) are passed on to the readsource method for the segment's src class.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/Segment.m#L51-L57\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"SegmentResult\" class=\"docstring-binding\" href=\"#SegmentResult\"><code>SegmentResult</code></a>\n         â€”\n        <span class=\"docstring-category\">Class</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"segres = SegmentResult(seg)\nsegres = SegmentResult(seg, results)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Contains a segment and the results of an analysis.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Input arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"seg: A Segment\nresults: (Optional) A struct where each field is an individual result. If omitted,","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"an empty struct will be created.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/blob/master/matlab/SegmentResult.m#L1-L11\">source</a>\n    </section>\n</article>","category":"page"},{"location":"concepts/subsets/#Data-Subsets","page":"Data Subsets","title":"Data Subsets","text":"","category":"section"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"A DataSubset is a type [Julia] or class [MATLAB] that describes a group of sources of a single kind of Source in a dataset.","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"A dataset can have multiple different kinds of sources, which may be located and/or organized in different manners (e.g. due to being created with different software or on different systems). So we use the term DataSubset to refer to these subsets of a dataset.","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"In simple cases, the files in a DataSubset might be all of the files within a single directory, e.g. /data/events/. However, in many cases, the files may be organized with a more complex structure, involving multiple folders and subfolders. For these situations, a glob is used to specify the locations and files/filetypes that are a part of the subset. For example, instead of including all the files in a folder, /data/events/, a specific filetype can be specified: /data/events/*.csv","category":"page"},{"location":"concepts/subsets/#Examples","page":"Data Subsets","title":"Examples","text":"","category":"section"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"using DatasetManager\nstruct Events; end\nstruct C3DFile; end","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"This is an example of a DataSubset named \"events\" of Source{Events}. Note the wildcard after \"Subject\", which will match any text (e.g. \"Subject 12/events/...\" or \"Subject 13_BAD/events/...\").","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"DataSubset(\"events\", Source{Events}, \"/path/to/subset\", \"Subject */events/*.tsv\")","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"Alternately, the following is slightly more specific because the wildcard after \"Subject\" is limited to the characters 0 through 9.","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"DataSubset(\"events\", Source{Events}, \"/path/to/subset\", \"Subject [0-9]*/events/*.tsv\")","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"In some cases, a more specific glob may be necessary or preferable to exclude certain folders/files, due to the organization of sources, or for performance (if the more specific glob matches significantly fewer files), however in many cases, a simpler, less specific glob will be perfectly acceptable.","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"The folder given as the third argument should be the deepest, non-glob containing (e.g. *, etc) path. Globs in the third argument will cause errors, and a shallower path split (e.g. \"/path/to/\", \"subset/Subject */events/*.tsv\" vs \"/path/to/subset/\", \"Subject */events/*.tsv\") may be noticeably slower (due to searching more files and folders).","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"The source type for DataSubsets in MATLAB is prefixed with an ampersand (@) to denote that we are referring to the class itself, not an instance of the class. More info here and here.","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"DataSubset('events', @EventsSource, '/path/to/subset/Subject */events/*.tsv')","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"Globbing support is different in MATLAB, and the complete path, including globs, is given as a single string; additionally, only asterisk globs are supported in MATLAB. More info here.","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/subsets/#Dependent-subsets","page":"Data Subsets","title":"Dependent subsets","text":"","category":"section"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"(The following refers to concepts which haven't been introduced yet. Read Trials and TrialConditions for background information.)","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"Some sources described by a DataSubset may not be relevant as standalone/independent Trials (e.g. maximal voluntary contraction \"trials\", when collecting EMG data, are typically only relevant to movement trials for that specific subject/session of a data collection, but are may not be useful on their own).","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"When findtrials is called with a dependent DataSubset, sources will only be added to pre-existing trials and no new trials will be created solely for a dependent source. Dependent sources are only added to trials when the required conditions for the dependent DataSubset match the corresponding conditions in the trials.","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"labels = Dict(\n    :subject => r\"(?<=Patient )\\\\d+\",\n    :session => r\"(?<=Session )\\\\d+\",\n    :mvic => r\"mvic_[rl](bic|tric)\", # Defines possible source names for MVIC \"trials\"\n);\nconds = TrialConditions((:subject,:session,:mvic), labels;\n    required=(:subject,:session,));\nsubsets = [\n    DataSubset(\"mvic\", Source{C3DFile}, \"/path/to/c3d\", \"Subject */Session */*.c3d\";\n        dependent=true)\n];","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"The pattern for the :mvic \"condition\" would match any of [\"mvic_rbic\", \"mvic_lbic\", \"mvic_rtric\", \"mvic_ltric\"].","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"The dependent \"mvic\" subset has the :subject and :session conditions set as required, so only sources (that match the :mvic pattern) with matching :subject and :session will be added to a given trial. For example, a source with a filename of \"Subject 3/Session 2/mvic_rbic.c3d\" would be recognized as having conditions (:subject => 3, :session => 2, :mvic => \"mvic_rbic\") and would be added as a source to any trial(s) with conditions  (:subject => 3, :session => 2).","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"warning: Dependent source names\nNote that the names of dependent sources are determined differently than regular sources. While regular sources are given the name of the DataSubset they originate from (e.g. \"mvic\"), this would cause DuplicateSourceErrors if multiple (and unique) dependent sources were needed for a Trial. Instead, dependent sources are named using the (value of the) \"condition\" which matches the DataSubset name. Using the above example, the \"mvic\" subset looks for a \"condition\" with the same name (e.g. :mvic), and the source name is set to the value of the matched condition: \"mvic_rbic\".","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"[Not implemented yet]","category":"page"},{"location":"concepts/subsets/","page":"Data Subsets","title":"Data Subsets","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/trials/#Trials","page":"Trials","title":"Trials","text":"","category":"section"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"A Trial is a type [Julia] or class [MATLAB] that describes a single (temporal) instance of data collected from a specific subject. Trials are primarily descriptive, and do not contain the data that was collected during the trial. Trials record the (unique) subject identifier, experimental conditions (or other relevant metadata, such as subject specific characteristics), and they have have one or more Sources which refer to the files containing the actual data collected during the trial.","category":"page"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"using DatasetManager","category":"page"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"trial1 = Trial(1, \"baseline\", Dict(:group => \"control\", :session => 2))","category":"page"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"Trial('1', 'baseline', struct('group', 'Control', 'session', 2))","category":"page"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"ans =\n\n  Trial with properties:\n\n       subject: '1'\n          name: 'baseline'\n    conditions: [1Ã—1 struct]\n       sources: [1Ã—1 struct]","category":"page"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"The descriptive nature of Trials makes it easy to include or exclude trials for an analysis based on conditions, etc. Various convenience functions have been defined for this purpose: hassubject, hascondition, and hassource.","category":"page"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"using DatasetManager","category":"page"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"trials = [ Trial(id, \"\", Dict(:group => group, :week => week, :stimulus => stim))\n    for id in 1:5\n    for group in 'A':'B'\n    for week in 1:4\n    for stim in (\"sham\", \"low\", \"high\") ];\ntrials |> summary\ntrials[hascondition.(trials, :group => 'A')] |> summary\ntrials[hascondition.(trials, :group => 'A', :stimulus => (\"low\", \"high\"))] |> summary\nfilter(hassubject(3), trials) |> summary","category":"page"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"</div>\n</div>\n</p>","category":"page"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"<div class=\"admonition\">\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB</summary>\n<div class=\"admonition-body\" style=\"background-color:white\">","category":"page"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"trials = Trial.empty();\nfor id = 1:5\nfor group = ['A', 'B']\nfor week = 1:4\nfor stim = {'sham', 'low', 'high'}\ntrials(end+1) = Trial(num2str(id), '', struct('group', group, 'week', week, 'stim', stim));\nend\nend\nend\nend\n\n% TODO Add hascondition examples","category":"page"},{"location":"concepts/trials/","page":"Trials","title":"Trials","text":"</div>\n</div>\n</p>","category":"page"},{"location":"examples/sources/#Working-with-sources","page":"Working with sources","title":"Working with sources","text":"","category":"section"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"warning: Warning: Sources and MATLAB\nThis feature has not been implemented yet in MATLAB.","category":"page"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"It is common for data to be stored in different ways, such as text-delimited files and binary files. Therefore, different code will most likely be needed to read the different formats. DatasetManager calls these different data storage formats 'sources', and different functions can be written specific to each type of source.","category":"page"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"A simple implementation of a source for an OpenSim .mot file follows:","category":"page"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"The default Source type is sufficient for this example. We create a","category":"page"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"struct OpenSimMOT; end","category":"page"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"and then we provide a readsource method. This source is a csv text file, so we will use TextParse.jl to read it in Julia.","category":"page"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"using CSV, DataFrames\nfunction DatasetManager.readsource(src::Source{OpenSimMOT}; kwargs...)\n    data = CSV.File(sourcepath(src); header=11, delim='\\t', kwargs...) |> DataFrame\n\n    return data\nend","category":"page"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"This is the minimal implementation needed to define a new Source. However, there are some additional methods which can be convenient to define.","category":"page"},{"location":"examples/sources/#Adding-a-readsegment-method","page":"Working with sources","title":"Adding a readsegment method","text":"","category":"section"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"A readsegment method should return a semantically equivalent result to readsource(seg.source)[start:finish]. Here is a method for our OpenSimMOT source:","category":"page"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"function DatasetManager.readsegment(seg::Segment{OSimMotion}; kwargs...)\n    data = readsource(seg.source; kwargs...)\n    if !isnothing(seg.start)\n        starti = searchsortedfirst(data[!, \"time\"], seg.start)\n    else\n        starti = firstindex(data, 1)\n    end\n\n    if !isnothing(seg.finish)\n        lasti = searchsortedlast(data[!, \"time\"], seg.finish)\n    else\n        lasti = lastindex(data, 1)\n    end\n\n    return data[starti:lasti, :]\nend","category":"page"},{"location":"examples/sources/#Automatically-generating-sources","page":"Working with sources","title":"Automatically generating sources","text":"","category":"section"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"Sometimes a source can be generated from another source (or sources). This could be a simple file conversion (e.g. .c3d to .trc), or something more involved, such as running inverse kinematics in OpenSim.","category":"page"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"To support generating a source, a DatasetManager.dependencies method must be defined to declare what other sources must be present in order to generate the source of interest.","category":"page"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"struct TRC; end\nDatasetManager.dependencies(::Source{TRC}) = (Source{C3DFile},)","category":"page"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"Then, a DatasetManager.generatesource method must be defined which performs the source generation.","category":"page"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"function DatasetManager.generatesource(trial, src::Source{TRC}, deps)\n    writetrc(sourcepath(src), readsource(trial, Source{C3DFile}))\nend","category":"page"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"With those two methods now defined, the requiresource! function can be called, which will generate the TRC source if it is not already present, and add it to the trial.sources:","category":"page"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"requiresource!(trial, Source{TRC})\n\n# Re-generate the `TRC` source, even if one already exists\nrequiresource!(trial, Source{TRC}; force=true)\n\n# Override the default dependencies and use a specific `Source{C3DFile}`\n# This would only work if the `generatesource` function was designed to allow such an\n# override\nrequiresource!(trial, Source{TRC}; deps=(\"imu-c3d\",))","category":"page"},{"location":"examples/sources/","page":"Working with sources","title":"Working with sources","text":"Examples of more complex sources (readsource, generatesource, etc) can be found at LabDataSources.jl.","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DatasetManager","category":"page"},{"location":"#DatasetManager","page":"Home","title":"DatasetManager","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Find your data, summarize high-level characteristics, analyze it, and collect the results for statistical testing!","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DatasetManager, DataFrames, CSV\ninclude(joinpath(pkgdir(DatasetManager), \"test\", \"makedata.jl\"))\ngensimpledata()\ndatadir = relpath(joinpath(pkgdir(DatasetManager), \"test/data/simple\"))\nstruct GaitEvents; end\nsubsets = [ DataSubset(\"events\", Source{GaitEvents}, datadir, \"*.csv\") ]\nconds = TrialConditions((:session,:stim), Dict(:session => r\"\\d\", :stim => [\"stim\", \"placebo\"]);\n    subject_fmt=r\"ID(?<subject>\\d+)\", types=Dict(:session => Int, :stim => String))\nENV[\"LINES\"] = 17","category":"page"},{"location":"","page":"Home","title":"Home","text":"using DatasetManager, DataFrames, CSV, Statistics\ntrials = findtrials(subsets, conds;\n    ignorefiles=[joinpath(datadir, \"ID4_3_stim-02.csv\")]);\nsummarize(trials)\nanalysis_results = analyzedataset(trials, Source{GaitEvents}) do trial\n    events = CSV.File(sourcepath(getsource(trial, \"events\"))) |> DataFrame\n    res = SegmentResult(Segment(trial, \"events\"))\n    results(res)[\"avg_stride\"] = mean(diff(events[!, \"RHS\"]))\n\n    return res\nend;\ndf = DatasetManager.stack(analysis_results, conds)","category":"page"},{"location":"","page":"Home","title":"Home","text":"DatasetManager was designed to solve several common problems when working with new datasets from human subjects research studies with the overall goal of reducing the amount of repetitive and custom code needed for new research by providing a flexible framework that can work with many different datasets.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The core functionality of DatasetManager eases the analysis of a new dataset by allowing the researcher to describe the dataset (e.g. the locations of the various sources of data, naming formats, etc) and then finding all the trials and associated metadata (e.g. unique subject ID, trial conditions, etc) in the dataset. Additional functionality includes the ability to define segments of the timeseries of a trial and attach experimental conditions specific to those segments, and a user-extensible common interface for reading/loading different sources of data based on the data type.","category":"page"},{"location":"#Key-functionality","page":"Home","title":"Key functionality","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The findtrials function returns a list of every trial in the dataset when given a description of how and where the data is stored, paving the way for batch processing of the dataset.\nMost datasets have a unique organization and structure to how and where the data is stored on disk. Similarly, many datasets will use different naming schemes for trials and experimental conditions, based on the needs of the study and the preferences of the researcher. These unique aspects of each dataset normally require writing custom code to find and interpret the naming for every new dataset, which wastes valuable time the researcher could be spending developing analyses or interpreting results.\nData Sources allow the researcher to define a standard function for reading (and even generating/transforming) a particular type of data (e.g. a file type/extension, or a specifically formatted .csv, etc).\nDatasets often have more than one source of data per trial (e.g. if multiple systems were used to collect different kinds of data, such as EMG and motion capture). These different kinds of data require special code to load them for analysis. Furthermore, even within the same file extension (e.g. .csv), files can have different data organization (e.g. the number of lines in the header) which would benefit from special handling; these differences can challenge the use of file extension as the basis for choosing which function is appropriate for reading a particular file.\nSegments describe a specific interval (the start time and end time) within a given trial and any experimental conditions specific to that interval of time.\nOftentimes, the entirety of a trial may not be needed, such as if the first part of a trial isn't used, or if a trial contains multiple different experimental conditions applied at different intervals throughout the duration of the trial.\nThe analyzedataset function will batch process (with multiple threads if available) all trials or segments using any given analysis function.\nCollect analysis results and all trial metadata (subject ID's, conditions, etc) into a DataFrame using DatasetManager.stack[1]","category":"page"},{"location":"#Limitations","page":"Home","title":"Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The findtrials function currently requires all the desired trial metadata (e.g. subject identifier, experimental conditions, etc) to be present in the absolute path of every trial. The ability to find trial metadata in alternate formats or locations (e.g. trial metadata is stored in separate files) is a feature we plan to add in the future.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Different sources are collated into a single trial when the subject identifier and all experiemental conditions match. Duplicate trials (in terms of identical experimental conditions and subject ID with no other distinguishing elements) are not currently supported.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please open an issue if you have a request for a feature that would be a good fit for this package, or if you have any issues using this package.","category":"page"},{"location":"","page":"Home","title":"Home","text":"[1]: DatasetManager.stack is not exported due to a naming conflict with the stack function in DataFrames.jl.","category":"page"},{"location":"julia-reference/#Julia-Reference","page":"Julia Reference","title":"Julia Reference","text":"","category":"section"},{"location":"julia-reference/","page":"Julia Reference","title":"Julia Reference","text":"TrialConditions\nDataSubset\nTrial\nsubject\nconditions\nsources\nhassubject\nhassource\nhascondition\ngetsource\nfindtrials\nfindtrials!\nsummarize\nanalyzedataset\nDatasetManager.stack\nwrite_results\nexport_trials","category":"page"},{"location":"julia-reference/#DatasetManager.TrialConditions","page":"Julia Reference","title":"DatasetManager.TrialConditions","text":"TrialConditions(conditions, labels; [required, types, defaults, subject_fmt])\n\nDefine the names of experimental conditions (aka factors) and the possible labels within each condition. Conditions are determined from the absolute path of potential sources.\n\nsubject is a reserved condition name for the unique identifier (ID) of individual subjects/participants in the dataset. If :subject is not explicitly included in conditions, it will be inserted at the beginning of conditions. The format of the subject identifier can be specified in labels or using the keyword argument subject_fmt.\n\nArguments\n\nconditions is a collection of condition names (eg (:medication, :dose)) in the order they must appear in the file paths of trial sources\nlabels must have a key-value pair for each condition. The value(s) for each key define the acceptable labels for each condition. Levels may be defined using a:\nString\nRegex\nold => transf [=> new], where old may be a Regex or one/multiple String(s), where transf may be a String, Function, or a SubstitutionString (only if old is a Regex), and where new is a Regex\nArray of any combination of the preceding.\nKeys in labels which are not included in conditions will be ignored.\n\nKeyword arguments\n\nrequired=conditions: The conditions which every trial is required to have.\ntypes=Dict(conditions .=> String): The types that each condition should be parsed as\ndefaults=Dict{Symbol,Any}(): Default conditions to set when a given condition is not matched. Defaults can given for required conditions. If a condition is not required, has no default, and is not matched, it will not be included as a condition for a source.\nsubject_fmt=r\"Subject (?<subject>\\d+)?\": The Regex pattern used to match the trial's   subject ID. If :subject is present in labels, that definition will take precedence.\n\nExamples\n\njulia> labels = Dict(\n    :subject => r\"(?<=Patient )\\d+\",\n    :group => [\"Placebo\" => \"Control\", \"Group A\", \"Group B\"],\n    :posture => r\"(sit|stand)\"i => lowercase,\n    :cue => r\"cue[-_](fast|slow)\" => s\"\\\\1 cue\" => r\"(fast|slow) cue\");\n\njulia> conds = TrialConditions((:subject,:group,:posture,:cue), labels;\n    types=Dict(:subject => Int));\n\n\n\n\n\n","category":"type"},{"location":"julia-reference/#DatasetManager.DataSubset","page":"Julia Reference","title":"DatasetManager.DataSubset","text":"DataSubset(name, source::Union{Function,<:AbstractSource}, dir, pattern; [dependent=false])\n\nDescribes a subset of source data files found within a folder dir which match pattern (using glob syntax). The name of the DataSubset will be used in findtrials as the source name in a Trial.\n\nSome sources described by a DataSubset may not be relevant as standalone/independent Trials (e.g. maximal voluntary contraction \"trials\", when collecting EMG data, are typically only relevant to movement trials for that specific subject/session of a data collection, but are not useful on their own). Dependent sources (eg dependent=true) will not create new trials in findtrials and will only be added to pre-existing trials when the required conditions and a \"condition\" with the same name as the DataSubset's name exists. The matched \"condition\" will be used in findtrials! as the source name in corresponding Trials.\n\nIf source is a function, it must accept a file path and return a Source.\n\nSee also: Source, TrialConditions, findtrials, findtrials!\n\nExamples\n\njulia> DataSubset(\"events\", Source{Events}, \"/path/to/subset\", \"Subject [0-9]*/events/*.tsv\")\nDataSubset(\"events\", Source{Events}, \"/path/to/subset\", \"Subject [0-9]*/events/*.tsv\")\n\n\nDataSubsets for dependent sources\n\njulia> labels = Dict(\n        :subject => r\"(?<=Patient )\\d+\",\n        :session => r\"(?<=Session )\\d+\",\n        :mvic => r\"mvic_[rl](bic|tric)\", # Defines possible MVIC \"trial\" names\n    );\n\njulia> # Only :subject and :session are required conditions (for matching existing trials)\njulia> conds = TrialConditions((:subject,:session,:mvic), labels; required=(:subject,:session,));\n\njulia> # Note the DataSubset name matches the \"condition\" name in `labels`\njulia> subsets = [\n    DataSubset(\"mvic\", Source{C3DFile}, c3dpath, \"Subject [0-9]*/Session [0-2]/*.c3d\"; dependent=true)\n];\n\njulia> findtrials!(trials, subsets, conds)\n\n\n\n\n\n","category":"type"},{"location":"julia-reference/#DatasetManager.Trial","page":"Julia Reference","title":"DatasetManager.Trial","text":"Trial{ID}(subject::ID, name::String, [conditions::Dict{Symbol}, sources::Dict{String}])\n\nCharacterizes a single instance of data collected from a specific subject. The Trial has a name, and may have one or more conditions which describe experimental conditions and/or subject specific charateristics which are relevant to subsequent analyses. A Trial may have one or more complementary sources of data (e.g. simultaneous recordings from separate equipment stored in separate files, supplementary data for a primary data source, etc).\n\nExamples\n\njulia> trial1 = Trial(1, \"baseline\", Dict(:group => \"control\", :session => 2))\nTrial{Int64}\n  Subject: 1\n  Name: baseline\n  Conditions:\n    :group => \"control\"\n    :session => 2\n  No sources\n\n\n\n\n\n","category":"type"},{"location":"julia-reference/#DatasetManager.subject","page":"Julia Reference","title":"DatasetManager.subject","text":"subject(trial::Trial{ID}) -> ID\nsubject(seg::Union{Segment,SegmentResult}) -> ID\n\nGet the subject identifier of a Trial, Segment, or SegmentResult.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.conditions","page":"Julia Reference","title":"DatasetManager.conditions","text":"conditions(trial::Trial{ID}) -> Dict{Symbol,Any}\nconditions(seg::Union{Segment,SegmentResult}) -> Dict{Symbol}\n\nGet the conditions of a Trial, Segment, or SegmentResult.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.sources","page":"Julia Reference","title":"DatasetManager.sources","text":"sources(trial::Trial{ID}) -> Dict{String,AbstractSource}\n\nGet the sources for trial\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.hassubject","page":"Julia Reference","title":"DatasetManager.hassubject","text":"hassubject(trial, sub) -> Bool\n\nTest if the subject ID for trial is equal to sub\n\n\n\n\n\nhassubject(sub) -> Bool\n\nCreate a function that tests if the subject ID of a trial is equal to sub, i.e. a function equivalent to t -> hassubject(t, sub).\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.hassource","page":"Julia Reference","title":"DatasetManager.hassource","text":"hassource(trial, src::String) -> Bool\nhassource(trial, srctype::S) where {S<:AbstractSource} -> Bool\nhassource(trial, src::Regex) -> Bool\n\nCheck if trial has a source with key or type matching src.\n\nExamples\n\njulia> trial1 = Trial(1, \"baseline\", Dict(), Dict(\"model\" => Source{Nothing}()));\n\njulia> hassource(trial1, \"model\")\ntrue\n\njulia> hassource(trial1, Source{Nothing})\ntrue\n\njulia> hassource(trial1, r\"test*\")\nfalse\n\n\n\n\n\nhassource(src) -> Bool\n\nCreate a function that tests if a trial has the source src, i.e. a function equivalent to t -> hassource(t, src).\n\nExamples\n\njulia> trial1 = Trial(1, \"baseline\", Dict(), Dict(\"model\" => Source{Nothing}()));\n\njulia> trial2 = Trial(2, \"baseline\");\n\njulia> filter(hassource(\"model\"), [trial1, trial2])\n1-element Vector{Trial{Int64}}:\n Trial(1, \"baseline\", 0 conditions, 1 source)\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.hascondition","page":"Julia Reference","title":"DatasetManager.hascondition","text":"hascondition(trial, (condition [=> value])...) -> Bool\n\nTest if trial has condition, or that condition matches value. Specifying value is optional. Multiple conditions and/or condition pairs can be given which all must be true to match. value can be a single level, multiple acceptable levels, or a predicate function.\n\nExamples\n\njulia> trial = Trial(1, \"baseline\", Dict(:group => \"control\", :session => 2));\n\njulia> hascondition(trial, :group)\ntrue\n\njulia> hascondition(trial, :group => \"A\")\nfalse\n\njulia> hascondition(trial, :group => [\"control\", \"A\"])\ntrue\n\njulia> hascondition(trial, :group => \"A\", :session => 1)\nfalse\n\njulia> hascondition(trial, :group => [\"control\", \"A\"], :session => >=(2))\ntrue\n\n\n\n\n\n\nhascondition((condition => value)...) -> Bool\n\nCreate a function that tests if a trial has the given condition(s)/value(s), i.e. a function equivalent to t -> hascondition(t, conditions...).\n\nExamples\n\njulia> trial1 = Trial(1, \"baseline\", Dict(:group => \"control\", :session => 2));\n\njulia> trial2 = Trial(2, \"baseline\", Dict(:group => \"A\", :session => 1));\n\njulia> filter(hascondition(:group => \"A\"), [trial1, trial2])\n1-element Vector{Trial{Int64}}:\n Trial(2, \"baseline\", 2 conditions, 0 sources)\n\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.getsource","page":"Julia Reference","title":"DatasetManager.getsource","text":"getsource(trial, name::String) -> Source\ngetsource(trial, src::S) where {S<:AbstractSource} -> Source\ngetsource(trial, name::String => src::Type{<:AbstractSource}) -> Source\ngetsource(trial, pattern::Regex) -> Vector{Source}\n\nReturn a source from trial with the requested name or src. When the both name and src are given as a pair, a source with name will be searched for first, and if not found, a source of type src will be searched for. When src (as an <:AbstractSource) is given, only a source of type src may be present, otherwise an error will be thrown.\n\nIf a Regex pattern is given, multiple sources may be returned.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.findtrials","page":"Julia Reference","title":"DatasetManager.findtrials","text":"findtrials(subsets, conditions; <keyword arguments>) -> Vector{Trial}\n\nFind all the trials matching conditions which can be found in subsets.\n\nKeyword arguments:\n\nignorefiles::Union{Nothing, Vector{String}}=nothing: A list of files, given in the form  of an absolute path, that are in any of the subsets folders which are to be ignored.\ndebug=false: Show files that did not match (all) the required conditions\nverbose=false: Show files that did match all required conditions when debug=true\nmaxlogs=50: Maximum number of files per subset to show when debugging\n\nSee also: Trial, findtrials!, DataSubset, TrialConditions\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.findtrials!","page":"Julia Reference","title":"DatasetManager.findtrials!","text":"findtrials!(trials, subsets, conditions; <keyword arguments>) -> Vector{Trial}\n\nFind more trials and/or additional sources for existing trials.\n\nFor DataSubsets in subsets which are dependent, candidate source files must have the required conditions and have a \"condition\" matching the DataSubset name.\n\nSee also: findtrials, Trial, DataSubset, TrialConditions\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.summarize","page":"Julia Reference","title":"DatasetManager.summarize","text":"summarize([io,] trials; [verbosity=5, ignoreconditions])\n\nSummarize a vector of Trials.\n\nExamples\n\njulia> summarize(trials)\nSubjects:\n â”” 10: \"1\"  \"2\"  \"3\"  \"4\"  \"5\"  \"6\"  \"7\"  \"8\"  \"9\"  \"10\"\nTrials:\n â”œ 40 trials\n â”” Trials per subject:\n   â”” 4: 10 subjects (100%)\nConditions:\n â”œ Observed levels:\n â”‚ â”œ stim => [\"placebo\", \"stim\"]\n â”‚ â”” session => [1, 2]\n â”” Unique level combinations observed: 4 (full factorial)\n        stim â”‚ session â”‚ # trials\n    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     placebo â”‚       1 â”‚ 10\n        stim â”‚       1 â”‚ 10\n     placebo â”‚       2 â”‚ 10\n        stim â”‚       2 â”‚ 10\nSources:\n â”” \"events\" => Source{GaitEvents}, 40 trials (100%)\n\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.analyzedataset","page":"Julia Reference","title":"DatasetManager.analyzedataset","text":"analyzedataset(f, trials, Type{<:AbstractSource}; [enable_progress, show_errors, threaded]) -> Vector{SegmentResult}\n\nMap function f over all trials (multi-threaded by default) and return the SegmentResult. If f errors for a given trial, the SegmentResult for that trial will be empty (no results), and the error will be rethrown along with the trial which caused the error.\n\nKeyword arguments\n\nenable_progress=true: Enable the progress meter\nshow_errors=true: Show trials and their errors\nthreaded=true\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.stack","page":"Julia Reference","title":"DatasetManager.stack","text":"stack(rs::Vector{SegmentResult}, conds; [variables])\n\nCompile the results into a stacked, long form DataFrame\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.write_results","page":"Julia Reference","title":"DatasetManager.write_results","text":"write_results(filename, df, conditions; [variables, format, archive])\n\nWrite the results in df (generated by DatasetManager.stack) to file at filename. format may be :wide or :long. If archive == true, if filename already exists, it will be moved to \"$(filename).bak\" before writing the new results to filename.\n\nconditions and variables specifies which conditions or variables, respectively, should be included in the output.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.export_trials","page":"Julia Reference","title":"DatasetManager.export_trials","text":"export_trials([f,] trials, dir[, sources])\n\nExport (copy) sources in trials to outdir. When left unspecified, sources is set to all unique sources found in trials. Optionally can be given a function f, which must accept 2 arguments (a trial and a src which is of eltype(sources)), to control the names of the exported data. The default behavior exports all sources to dir with no subdirectories, using the naming schema \"trialsubject_srcname_basename(sourcepath)\" (pseudo-code).\n\nExamples\n\njulia> export_trials(trials, pwd()) do trial, source\n    \"$(subject(trial))_$(conditions(trial)[:group]).$(srcext(source))\"\nend\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#Sources","page":"Julia Reference","title":"Sources","text":"","category":"section"},{"location":"julia-reference/","page":"Julia Reference","title":"Julia Reference","text":"AbstractSource\nSource\nreadsource\nsourcepath\nrequiresource!\ngeneratesource\ndependencies\nDatasetManager.srcext\nDatasetManager.srcname_default","category":"page"},{"location":"julia-reference/#DatasetManager.AbstractSource","page":"Julia Reference","title":"DatasetManager.AbstractSource","text":"AbstractSource\n\nThe abstract supertype for custom sources. Implement a subtype of AbstractSource if Source{S} is not sufficient for your source requirements (e.g. your source has additional information besides the path, such as encoding parameters, compression indicator, etc, that needs to be associated with each instance).\n\nExtended help\n\nAbstractSource interface requirements\n\nAll subtypes of AbstractSource must:\n\nhave a path field or extend the sourcepath function.\nhave at least these two constructor methods:\nempty constructor\nsingle argument constructor accepting a string of an absolute path\n\nAbstractSource subtypes should:\n\nhave a readsource method\n\nAbstractSource subtypes may implement these additional methods to improve user experience and/or enable additional functionality:\n\nreadsegment\ngeneratesource (if enabling requiresource! generation)\ndependencies (if defining a generatesource method)\nsrcext\nsrcname_default\n\n\n\n\n\n","category":"type"},{"location":"julia-reference/#DatasetManager.Source","page":"Julia Reference","title":"DatasetManager.Source","text":"Source{S}([path])\n\nA standard/default source, where S can be an existing type or a singleton type defined for dispatch purposes. When path is omitted, a unique temporary file path is used.\n\nExamples\n\njulia> Source{Missing}()\nSource{Missing}(\"/tmp/jl_ruMeMy\")\n\njulia> struct RandomDev; end\n\njulia> Source{RandomDev}(\"/dev/urandom\")\nSource{RandomDev}(\"/dev/urandom\")\n\n\n\n\n\n","category":"type"},{"location":"julia-reference/#DatasetManager.readsource","page":"Julia Reference","title":"DatasetManager.readsource","text":"readsource(src::S; kwargs...) where {S <: AbstractSource}\n\nRead the source data from file.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.sourcepath","page":"Julia Reference","title":"DatasetManager.sourcepath","text":"sourcepath(src) -> String\n\nReturn the absolute path to the src.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.requiresource!","page":"Julia Reference","title":"DatasetManager.requiresource!","text":"requiresource!(trial, name::String; [force, deps, kwargs...]) -> nothing\nrequiresource!(trial, name::Regex; <keyword arguments>) -> nothing\nrequiresource!(trial, src::S; <keyword arguments>) where {S<:AbstractSource} -> nothing\nrequiresource!(trial, ::Type{S}; <keyword arguments>) where {S<:AbstractSource} -> nothing\nrequiresource!(trial, name::String => src; <keyword arguments>) -> nothing\n\nRequire src to be exist for trial. Generate src if it does not exist, or throw an error if src is not present and cannot be generated. When src is a Regex, deps is constrained to UnknownDeps, regardless of the keyword argument. Unused keyword arguments will be passed on to the generatesource method for src.\n\nKeyword arguments\n\nforce=false: Force generating src, even if it already exists\ndeps=dependencies(src): deps can be manually specified as a name => src::AbstractSource pair per dependency if there exist multiple sources that would match a dependent source type. kwargs... are passed on to the generatesource function for src.\n\nExamples\n\njulia> dependencies(Source{Events})\n(Source{C3DFile},)\n\njulia> requiresource!(trial, Source{Events})\n\njulia> requiresource!(trial, Source{Events}; force=true, deps=(\"mainc3d\" => Source{C3DFile}))\n\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.generatesource","page":"Julia Reference","title":"DatasetManager.generatesource","text":"generatesource(trial, src::Union{S,Type{S}}, deps; kwargs...) where S <: AbstractSource -> newsrc::typeof(src)\n\nGenerate source src using dependent sources deps from trial. Returns a source of the same type as src, but is not required to be exactly equal to src (i.e. a different sourcepath(newsrc) is acceptable). Keyword arguments named force and deps should not be used in generatesource methods since they are used in requiresource! and will not be passed on to the generatesource method.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.dependencies","page":"Julia Reference","title":"DatasetManager.dependencies","text":"dependencies(src::Union{S,Type{S}}) where {S<:AbstractSource} -> Tuple{<:AbstractSource}\n\nGet the sources that src depends on to be generated by generatesource. Defaults to UnknownDeps, which prevents automatically generating src.\n\nExtended help\n\nIn some cases, it may be preferable to leave the dependencies for custom source undefined if e.g. the source is a container of some form that may contain data generated and depending an unknown number/type of sources.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.srcext","page":"Julia Reference","title":"DatasetManager.srcext","text":"srcext(src::Type{S}) where {S<:AbstractSource} -> String\nsrcext(src::S) where {S<:AbstractSource} -> String\n\nReturn the file extension for src. If src is an AbstractSource subtype, the default extension for that subtype will be returned; if src is an AbstractSource instance, the returned extension will be the actual extension for that src, regardless of whether it is the same as the default extension for that src type.\n\nExtended help\n\nWhen extending this function for a custom source, only define a method for the source type, e.g. srcext(::Type{MySource}). The period (.) should be included in the extension as the first letter.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.srcname_default","page":"Julia Reference","title":"DatasetManager.srcname_default","text":"srcname_default(src::Union{S,Type{S}}) where {S<:AbstractSource} -> String\n\nGet the default name for a source of type S\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#Segments","page":"Julia Reference","title":"Segments","text":"","category":"section"},{"location":"julia-reference/","page":"Julia Reference","title":"Julia Reference","text":"Segment\nreadsegment\nSegmentResult\ntrial\nsegment\nsource\nresults\nresultsvariables","category":"page"},{"location":"julia-reference/#DatasetManager.Segment","page":"Julia Reference","title":"DatasetManager.Segment","text":"Segment(trial, src::Union{S,Type{S},String}; [start, finish, conditions])\n\nDescribes a portion of a source in trial from time start to finish with segment specific conditions, if applicable.\n\nIf src is a String or AbstractSource, it must refer to a source that exists in trial. start and finish are used in readsegment to trim time from the beginning and/or end of the data read from src. start and finish default to the beginning and end, respectively, of the source/trial. start must be before finish, but they are otherwise only validated during readsegment.\n\nAny conditions present in trial will be merged into the conditions for the segment. Note: if src is a <:AbstractSource instance, it will not be added to the trial's sources.\n\nExample:\n\njulia> t = Trial(1, \"intervention\", Dict(:group => \"control\"), Dict(\"events\" => Source{Events}(\"/path/to/file\")));\n\njulia> seg = Segment(t, \"events\")\nSegment{Source{Events},Int64}\n Trial: Trial(1, \"intervention\", 1 conditions, 1 source)\n Source: Source{Events}(\"/path/to/file\")\n Time: beginning to end\n Conditions: (same as parent trial)\n    :group => \"control\"\n\njulia> seg = Segment(t, Source{Events}(\"/new/events/file\"); start=0.0, finish=10.0, conditions=Dict(:stimulus => \"sham\"))\nSegment{Source{Events},Int64}\n Trial: Trial(1, \"intervention\", 1 conditions, 1 source)\n Source: Source{Events}(\"/new/events/file\")\n Time: 0.0 to 10.0\n Conditions:\n    :stimulus => \"sham\"\n    :group => \"control\"\n\n\n\n\n\n","category":"type"},{"location":"julia-reference/#DatasetManager.readsegment","page":"Julia Reference","title":"DatasetManager.readsegment","text":"readsegment(seg::Segment{S}; warn=true, kwargs...) where S <: AbstractSource\n\nIf defined for S, returns the portion of seg.source from seg.start to seg.finish. Otherwise, equivalent to readsource (i.e. no trimming of time-series occurs). Warns by default if the main method is called.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.SegmentResult","page":"Julia Reference","title":"DatasetManager.SegmentResult","text":"SegmentResult(segment::Segment, results::Dict{Symbol)\n\nContains the results of any analyses performed on the trial segment in a Dict.\n\nExample:\n\nsegresult = SegmentResult(seg, Dict(:avg => 3.5))\n\n\n\n\n\n","category":"type"},{"location":"julia-reference/#DatasetManager.trial","page":"Julia Reference","title":"DatasetManager.trial","text":"trial(seg::Union{Segment,SegmentResult}) -> Trial\n\nReturn the parent Trial for the given Segment or SegmentResult\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.segment","page":"Julia Reference","title":"DatasetManager.segment","text":"Get the segment of a SegmentResult\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.source","page":"Julia Reference","title":"DatasetManager.source","text":"source(seg::Union{Segment,SegmentResult}) -> AbstractSource\n\nReturn the source for the parent Trial of the given Segment or SegmentResult\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.results","page":"Julia Reference","title":"DatasetManager.results","text":"Get the results of a SegmentResult\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.resultsvariables","page":"Julia Reference","title":"DatasetManager.resultsvariables","text":"resultsvariables(sr::Union{SegmentResult,Vector{SegmentResult}})\n\nGet the unique variables for SegmentResults.\n\n\n\n\n\n","category":"function"}]
}
