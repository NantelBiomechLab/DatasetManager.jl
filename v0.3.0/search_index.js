var documenterSearchIndex = {"docs":
[{"location":"examples/datasets-examples/#Describing-datasets","page":"Describing datasets","title":"Describing datasets","text":"","category":"section"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"Below are two examples of datasets with different organizations and issues which demonstrate the capabilities of DatasetManager.","category":"page"},{"location":"examples/datasets-examples/#Well-organized-dataset-with-minimal-issues","page":"Describing datasets","title":"Well organized dataset with minimal issues","text":"","category":"section"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"Consider a dataset organized as follows:","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"ðŸ“‚ genpath\nâ”œ ðŸ“‚ Visual3D\nâ”‚ â”œ ðŸ“‚ Subject 1\nâ”‚ â”‚ â”œ ðŸ“‚ export\nâ”‚ â”‚ â”‚ â”” ðŸ“‚ park\nâ”‚ â”‚ â”‚   â”œ park-none.mat\nâ”‚ â”‚ â”‚   â”œ park-norm.mat\nâ”‚ â”‚ â”‚   â”” park-excess.mat\nâ”‚ â”‚ â”” ðŸ“‚ import\nâ”‚ â”œ ðŸ“‚ Subject 2\nâ”‚ â”Š\nâ”‚\nâ”” ðŸ“‚ DFlow\n  â”œ ðŸ“‚ Subject 1\n  â”‚ â”œ park-none.csv\n  â”‚ â”œ park-norm.csv\n  â”‚ â”œ park-excess.csv\n  â”‚ â”Š\n  â”œ ðŸ“‚ Subject 2\n  â”Š\n\nðŸ“‚ rawpath\nâ”œ ðŸ“‚ Subject 1\nâ”‚ â”” ðŸ“‚ _\nâ”‚   â”œ park-none.c3d\nâ”‚   â”œ park-norm.c3d\nâ”‚   â”œ park-excess.c3d\nâ”‚   â”Š\nâ”œ ðŸ“‚ Subject 2\nâ”Š","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"The dataset is organized into 3 separate folders, but all the trials use the same naming scheme between the different folders. Therefore, we can group the data into 3 different data subsets (genpath/Visual3D, genpath/DFlow, and rawpath) for this analysis based on their location and filetype. Each DataSubset gets a name, a source type, a parent directory, and a glob which describes the structure and location, and possibly more (eg extension), of the files specified by the DataSubset.","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details open=\"\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"genpath = \"path/to/one/subset\"\ndflowpath = \"path/to/another/subset\"\n\nparksubsets = [\n    DataSubset(\"visual3d\", V3DExportSource, joinpath(genpath, \"Visual3D\"), \"Subject [0-9]*/export/park/park-*.mat\"),\n    DataSubset(\"dflow\", DFlowSource, joinpath(genpath, \"DFlow\"), \"Subject [0-9]*/park-*.csv\"),\n    DataSubset(\"vicon\", C3DSource, rawpath, \"Subject [0-9]*/_/park-*.c3d\")\n]","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details>\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"genpath = 'path/to/one/subset'\ndflowpath = 'path/to/another/subset'\n\nparksubsets = [\n    DataSubset('visual3d', 'V3DExportSource', fullfile(genpath, 'Visual3D/Subject */export/park/park-*.mat')),\n    DataSubset('dflow', 'DFlowSource', fullfile(genpath, 'DFlow/Subject */park-*.csv')),\n    DataSubset('vicon', 'C3DSource', fullfile(rawpath, 'Subject */_/park-*.c3d'))\n]","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</p>\n<div class=\"admonition-body\">","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"info: Info\nThe MATLAB globbing syntax only supports asterisks. More info here.","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</div>\n</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"This dataset only has one condition (aka 'factor' in statistical contexts) with three levels. The dataset was created with different terms for 2 of the levels, and we also wish to improve the naming of some of the levels. Any trial with \"none\" in the path will be recognized as a \"held\" trial. If a trial happens to already have the new terminology (\"held\"), it will be recognized as a \"held\" trial. The \"norm\" condition is left unchanged, and will only match trials with \"norm\" in the path.","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details open=\"\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"levels = Dict(:arms => [\"none\" => \"held\", \"norm\", \"excess\" => \"active\"])\nparkconds = TrialConditions((:arms,), levels)","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details>\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"levels.arms(1).from = 'none'\nlevels.arms(1).to = 'held'\nlevels.arms(2).to = 'norm'\nlevels.arms(3).from = 'excess'\nlevels.arms(3).to = 'active'\n\nparkconds = TrialConditions.generate({'arms'}, levels)\n% alternately:\nparkconds = TrialConditions.generate(fieldnames(levels), levels)","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"The findtrials function will search every DataSubset for trials which match the TrialConditions:","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details open=\"\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"# Read all perturbations\nparktrials = findtrials(parksubsets, parkconds)","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details>\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"parktrials = DataSet.findtrials(parksubsets, parkconds)","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"tip: Dealing with duplicate or unwanted files\nIn some cases, there are duplicate (e.g. a trial was redone due to technical difficulties, etc) or unwanted (e.g. corrupted data, etc) files that will match the same set of conditions in a particular DataSubset, and the findtrials function will be unable to determine which file should be used for that DataSubset source. Suppose the first of attempt for a trial, \"Subject 01/_/park-norm.c3d\" had an issue, and it was repeated with a '-02' added after the trial name (\"Subject 01/_/park-norm-02.c3d\").julia> parktrials = findtrials(parksubsets, parkconds)\n\nERROR: DuplicateSourceError: Found \"vicon\" source file \"â€¦/Subject 01/_/park-norm-02.c3d\" for\n Trial(1, \"park-norm\", Dict{Symbol,Any}(:arms => \"norm\"), 3 sources) which already has\n a \"vicon\" source at \"â€¦/Subject 01/_/park-norm.c3d\"\nStacktrace:\n [1] findtrials(::Array{DataSubset,1}, ::TrialConditions; I::Type{T} where T, subject_fmt::Regex, ignorefiles::Array{String,1}, defaultconds::Nothing) at /home/user/.julia/dev/DatasetManager/src/trial.jl:232\n [2] top-level scope at REPL[7]:1This DuplicateSourceError alerts you that, for Trial(1, \"park-norm\", Dict{Symbol,Any}(:arms => \"norm\")) there are conflicting files for the \"vicon\" source, and gives you the names of the two files.  The solution is to add any duplicate or unwanted files to the ignorefiles keyword argument (or the 'IgnoreFiles' optional argument in MATLAB).Julia:# Read all perturbations\nparktrials = findtrials(parksubsets, parkconds; ignorefiles=[\n    joinpath(rawpath, \"Subject 01/_/park-norm-01.c3d\")\n])MATLAB:parktrials = DataSet.findtrials(parksubsets, parkconds, 'IgnoreFiles', { ...\n    fullfile(rawpath, 'Subject 01/_/park-norm-01.c3d')\n})","category":"page"},{"location":"examples/datasets-examples/#Dataset-with-different-naming-schemes","page":"Describing datasets","title":"Dataset with different naming schemes","text":"","category":"section"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"Consider a different dataset, organized as follows:","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"ðŸ“‚ v3dpath\nâ”œ ðŸ“‚ Subject 1\nâ”‚ â”œ ðŸ“‚ Export\nâ”‚ â”‚ â”œ 20181204_1400_NORMS_TR03.mat\nâ”‚ â”‚ â”œ 20181204_1400_NORMC_TR03.mat\nâ”‚ â”‚ â”œ 20181204_1400_NORM_PARK_TR03.mat\nâ”‚ â”‚ â”Š\nâ”‚ â”” ðŸ“‚ import\nâ”œ ðŸ“‚ Subject 2\nâ”‚ â”” ðŸ“‚ Export\nâ”‚   â”œ norm-singletask.mat\nâ”‚   â”œ Norm-dualtask.mat\nâ”‚   â”œ park-norm.mat\nâ”‚   â”Š\nâ”Š\n\nðŸ“‚ dflowpath\nâ”œ ðŸ“‚ N01\nâ”‚ â”œ 20181204_1400_1448_AS_BA_NP_N01_TR01.txt\nâ”‚ â”œ 20181204_1400_1501_AS_CO_NP_N01_TR01.txt\nâ”‚ â”œ 20181204_1400_1646_NA_TR_NP_N05_TR01.txt\nâ”‚ â”Š\nâ”œ ðŸ“‚ N02\nâ”Š","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"This analysis only needs 2 DataSubsets:","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details open=\"\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"v3dpath = \"path/to/one/subset\"\ndflowpath = \"path/to/another/subset\"\n\nparkdatafiles = [\n    DataSubset(\"visual3d\", V3DExportSource, v3dpath, \"Subject [0-9]*/Export/*.mat\"),\n    DataSubset(\"dflow\", RawDFlowPDSource, dflowpath, \"N[0-9]*/*.txt\")\n]","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details>\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"v3dpath = 'path/to/one/subset'\ndflowpath = 'path/to/another/subset'\n\nparkdatafiles = [\n    DataSubset('visual3d', 'V3DExportSource', fullfile(v3dpath, 'Subject */Export/*.mat')),\n    DataSubset('dflow', 'RawDFlowPDSource', fullfile(dflowpath, 'N*/*.txt'))\n]","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"This dataset has several issues which make the level filters more complex and require the use of Regex to properly find the conditions.","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"The \"visual3d\" subset isn't completely consistent in the naming. For example \"Norm\" was sometimes used instead of \"norm\", and \"dual\" was sometimes used instead of\n\"dualtask\".  The \"dflow\" subset used a completely different trial naming scheme. \"AS\" was used instead of \"norm\", \"BA\" instead of \"singletask\", etc.","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"Such conversions can be dealt with simply. However, a slightly more complex issue is that the \"singletask\" condition in the \"visual3d\" subset is denoted by an \"S\" following the \"arms\" factor. Just matching an \"S\" could match either the \"S\" in \"Subject\" or in \"RS\"; we need to only match an \"S\" that follows the \"arms\" factor, which can be specified by a positive lookbehind group in Regex, like this: \"(?<=NONE|NORM)S\". A similar Regex can be used to deal with the \"C\" for \"dualtask\".","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"A similar technique can be used to find the \"TR\" denoting the \"park\" condition, by using lookbehind and lookahead Regex groups. The naming scheme for the \"dflow\" subset contains \"TR\" for every trial (\"20181204_1400_1646_AS_TR_NP_N05_TR01.txt\"), unrelated to the \"park\" condition. However, we notice that the \"TR\" denoting the \"park\" condition has underscores on either side; based on that observation, we can write a Regex for these requirements as \"(?<=_)TR(?=_)\".","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details open=\"\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"labels = Dict(:arms => [[\"NONE\", \"NA\"] => \"held\", [\"AS\", \"Norm\", \"NORM\"] => \"norm\"],\n              :kind => [[\"(?<=NONE|NORM|held|norm)S\", \"BA\", \"single\"] => \"singletask\",\n                        [\"(?<=NONE|NORM|norm|held)C\", \"CO\",, \"CP\", \"dual\"] => \"dualtask\",\n                        \"PO\" => \"pert\", [\"PARK\", \"(?<=_)TR(?=_)\"] => \"park\"],\n              :pert_side => [\"R(?=[ST]|slip|trip)\" => \"right\", \"L(?=[ST]|slip|trip)\" => \"left\"],\n              :pert_type => [\"NP\" => \"steadystate\", \"(?<=[RL]|right|left)T\" => \"trip\", \"(?<=[RL]|right|left)S\" => \"slip\"])\nconds = TrialConditions((:arms,:kind,:pert_side,:pert_type), labels; required=(:arms,:kind))","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details>\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"labels.arms(1).from = {'NONE', 'NA'};\nlabels.arms(1).to = 'held';\nlabels.arms(2).from = {'AS', 'Norm', 'NORM'};\nlabels.arms(2).to = 'norm';\n\nlabels.kind(1).from = {'(?<=NONE|NORM|held|norm)S', 'BA', 'single'};\nlabels.kind(1).to = 'singletask';\nlabels.kind(2).from = {'(?<=NONE|NORM|norm|held)C', 'CO', 'CP', 'dual'};\nlabels.kind(2).to = 'dualtask';\nlabels.kind(3).from = 'PO';\nlabels.kind(3).to = 'pert';\nlabels.kind(4).from = {'park', '(?<=_)TR(?=_)'};\nlabels.kind(4).to = 'park' ;\n\nlabels.pert_side(1).from = 'R(?=[ST]|slip|trip)';\nlabels.pert_side(1).to = 'right';\nlabels.pert_side(2).from = 'L(?=[ST]|slip|trip)';\nlabels.pert_side(2).to = 'left';\n\nlabels.pert_type(1).from = 'NP';\nlabels.pert_type(1).to = 'steadystate';\nlabels.pert_type(2).from = '(?<=[RL]|right|left)T';\nlabels.pert_type(2).to = 'trip';\nlabels.pert_type(3).from = '(?<=[RL]|right|left)S';\nlabels.pert_type(3).to = 'slip';\n\nconds = TrialConditions.generate({'arms','kind','pert_side','pert_type'}, labels, 'Required', {'arms', 'kind'})","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"note: Note\nThese TrialConditions also include the optional factors of pert_side and pert_type. When the required ('Required' in MATLAB) keyword arg is not specified, it is assumed that all factors are required. In this case, the \"visual3d\" subset only included the pert_side and pert_type levels for trials that included a perturbation.","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"As always, the findtrials function will locate trials and sources within each subset which match the given conditions.","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details open=\"\">\n<summary class=\"admonition-header code-icon julia-icon\">Julia code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"# Read all perturbations\nparktrials = findtrials(parkdatafiles, conds;\n    subject_fmt=r\"(?<=Subject |N)(?<subject>\\d+)\", ignorefiles=[\n        joinpath(dflowpath, \"N02/20181206_1500_1554_NA_BA_NP_N02_TR01.txt\"),\n        joinpath(dflowpath, \"N02/20181206_1500_1657_AS_CP_RT_N02_TR01.txt\"),\n        â‹®\n        joinpath(dflowpath, \"N020/20190509_1000_1113_NA_CP_RS_N020_TR01.txt\"),\n        joinpath(dflowpath, \"N020/20190509_1000_1153_AS_PO_LT_N020_TR01.txt\")\n    ], defaultconds=Dict(:pert_type => \"steadystate\"))","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"<div class=\"admonition\">\n<details>\n<summary class=\"admonition-header code-icon matlab-icon\">MATLAB code</summary>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"% Read all perturbations\nparktrials = DataSet.findtrials(parkdatafiles, conds, ...\n    'SubjectFormat', '(?<=Subject |N)(?<subject>\\d+)', 'IgnoreFiles', { ...\n        fullfile(dflowpath, 'N02/20181206_1500_1554_NA_BA_NP_N02_TR01.txt'), ...\n        fullfile(dflowpath, 'N02/20181206_1500_1657_AS_CP_RT_N02_TR01.txt'), ...\n        â‹®\n        fullfile(dflowpath, 'N020/20190509_1000_1113_NA_CP_RS_N020_TR01.txt'), ...\n        fullfile(dflowpath, 'N020/20190509_1000_1153_AS_PO_LT_N020_TR01.txt') ...\n    }, 'DefaultConditions', containers.Map('pert_type', 'steadystate'))","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"</details>\n</div>\n</p>","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"tip: Keyword arg: `subject_fmt` (`'SubjectFormat'` in MATLAB)\nThe subject_fmt Regex has been modified here to match the subject id between the different naming schemes of the two DataSubsets.","category":"page"},{"location":"examples/datasets-examples/","page":"Describing datasets","title":"Describing datasets","text":"tip: Keyword arg: `defaultconds` (`'DefaultConditions'` in MATLAB)\nThe defaultconds Dict can be particularly useful when some conditions are optional, and therefore may not exist in the file path, but are needed or desired in the Trials.","category":"page"},{"location":"matlab-reference/#MATLAB-Reference","page":"MATLAB Reference","title":"MATLAB Reference","text":"","category":"section"},{"location":"matlab-reference/#Trials","page":"MATLAB Reference","title":"Trials","text":"","category":"section"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"DataSubset\" class=\"docstring-binding\" href=\"#DataSubset\"><code>DataSubset</code></a>\n         â€” \n        <span class=\"docstring-category\">Class</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"DataSubset(name, source, pattern)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Describes a subset of data, where files found in and matching pattern (using glob syntax) are all of the same AbstractSource subclass.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/master/docs/src/matlab-reference.md#LL11-L28\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"TrialConditions\" class=\"docstring-binding\" href=\"#TrialConditions\"><code>TrialConditions</code></a>\n         â€” \n        <span class=\"docstring-category\">Class</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"TrialConditions","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Describes the experimental conditions and the labels for levels within each condition.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/master/docs/src/matlab-reference.md#LL11-L28\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"TrialConditions.generate\" class=\"docstring-binding\" href=\"#TrialConditions.generate\"><code>TrialConditions.generate</code></a>\n         â€” \n        <span class=\"docstring-category\">Function</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"TrialConditions.generate(conditions, labels, <optional arguments>)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Generates a TrialConditions.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"conditions is a cell array of condition names (eg {'medication', 'strength'})\nlabels is a struct with a field for each condition name (eg isfield(labels, 'medication')). Each condition field must have to and from fields which contain the final names and all the name possibilities, respectively. The from field is is optional if the terminology in the filenames is the desired terminology.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Optional arguments","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"'Required' (defaults to all conditions): The conditions which every trial must have (in the case of some trials having optional/additional conditions).\n'Separator' (defaults to '[_-]'): The character separating condition labels","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/master/docs/src/matlab-reference.md#LL11-L28\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"Trial\" class=\"docstring-binding\" href=\"#Trial\"><code>Trial</code></a>\n         â€” \n        <span class=\"docstring-category\">Class</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Trial(subject, name, conditions, sources)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Describes a single trial, including a reference to the subject, trial name, trial conditions, and relevant sources of data.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/master/docs/src/matlab-reference.md#LL11-L28\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"Trial.findtrials\" class=\"docstring-binding\" href=\"#Trial.findtrials\"><code>Trial.findtrials</code></a>\n         â€” \n        <span class=\"docstring-category\">Class</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Trial.findtrials(subsets, conditions, <optional arguments>)","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Find all the trials matching conditions which can be found in subsets.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"Optional arguments:","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"'SubjectFormat'(default is \"(?<=Subject )(?<subject>\\\\d+)\"): The format (in Regex) that the subject identifier   will appear in file paths.\nIgnoreFiles (default is empty): A cell array of absolute file paths that are in any of the subsets folders which are to be ignored.\nDefaultConditions (default are none): Any conditions which should be set to a default   level if the condition is not found in the file path.","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/master/docs/src/matlab-reference.md#LL11-L28\">source</a>\n    </section>\n</article>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"<article class=\"docstring\">\n    <header>\n        <a id=\"name\" class=\"docstring-binding\" href=\"#name\"><code>name</code></a>\n         â€” \n        <span class=\"docstring-category\">Class</span>\n    </header>\n    <section>\n        <div>","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"","category":"page"},{"location":"matlab-reference/","page":"MATLAB Reference","title":"MATLAB Reference","text":"        </div>\n        <a class=\"docs-sourcelink\" target=\"_blank\" href=\"https://github.com/NantelBiomechLab/DatasetManager.jl/master/docs/src/matlab-reference.md#LL11-L28\">source</a>\n    </section>\n</article>","category":"page"},{"location":"examples/abstractsource-subtypes/#Using-AbstractSource-subtypes","page":"Defining AbstractSource subtypes","title":"Using AbstractSource subtypes","text":"","category":"section"},{"location":"examples/abstractsource-subtypes/","page":"Defining AbstractSource subtypes","title":"Defining AbstractSource subtypes","text":"warning: Warning: Sources and MATLAB\nThis feature has not been implemented yet in MATLAB.","category":"page"},{"location":"examples/abstractsource-subtypes/","page":"Defining AbstractSource subtypes","title":"Defining AbstractSource subtypes","text":"The multiple different sources of data for any single trial might all have different file formats. In such a case, different code will be needed to read each file format. Two function stubs, readsource and readsegment, are defined for AbstractSource subtypes to implement methods appropriate for the source.","category":"page"},{"location":"examples/abstractsource-subtypes/","page":"Defining AbstractSource subtypes","title":"Defining AbstractSource subtypes","text":"We will construct an example module that will fully implement the AbstractSource API.","category":"page"},{"location":"examples/abstractsource-subtypes/","page":"Defining AbstractSource subtypes","title":"Defining AbstractSource subtypes","text":"First, we define the type:","category":"page"},{"location":"examples/abstractsource-subtypes/","page":"Defining AbstractSource subtypes","title":"Defining AbstractSource subtypes","text":"struct DFlowSource <: AbstractSource\n    path::String\nend","category":"page"},{"location":"examples/abstractsource-subtypes/","page":"Defining AbstractSource subtypes","title":"Defining AbstractSource subtypes","text":"and then we provide a readsource method. This source is a csv text file, so we will use TextParse.jl to read it in Julia.","category":"page"},{"location":"examples/abstractsource-subtypes/","page":"Defining AbstractSource subtypes","title":"Defining AbstractSource subtypes","text":"function DatasetManager.readsource(s::DFlowSource; kwargs...)\n    Textparse.csvread(sourcepath(s); skiplines_begin=2, header_exists=false, kwargs...)\nend","category":"page"},{"location":"examples/abstractsource-subtypes/","page":"Defining AbstractSource subtypes","title":"Defining AbstractSource subtypes","text":"Finally, the readsegment method should produce a result equivalent to readsource(seg.source)[start:finish]. Here is the appropriate method for DFlowSource:","category":"page"},{"location":"examples/abstractsource-subtypes/","page":"Defining AbstractSource subtypes","title":"Defining AbstractSource subtypes","text":"function DatasetManager.readsegment(seg::Segment{DFlowSource}; kwargs...)\n    columns, colnames = readsource(seg.source; kwargs...)\n    firsttime = first(columns[timecol])\n    lasttime = last(columns[timecol])\n\n    if isnothing(seg.finish)\n        _finish = lasttime\n    else\n        _finish = seg.finish\n    end\n\n    firsttime â‰¤ seg.start â‰¤ lasttime || throw(error(\"$s start time $(seg.start) is not within\"*\n        \"the source time range of $firsttime:$lasttime\"))\n    firsttime â‰¤ _finish â‰¤ lasttime || throw(error(\"$s finish time $(seg.finish) is not within \"*\n        \"the source time range of $firsttime:$lasttime\"))\n\n    startidx = searchsortedfirst(columns[timecol], firsttime)\n\n    if isnothing(seg.finish)\n        finidx = lastindex(columns[timecol])\n    else\n        finidx = searchsortedlast(columns[timecol], seg.finish)\n    end\n\n    segcolumns = ntuple(i -> columns[i][startidx:finidx], length(columns))\n\n    return segcolumns, colnames\nend","category":"page"},{"location":"examples/abstractsource-subtypes/","page":"Defining AbstractSource subtypes","title":"Defining AbstractSource subtypes","text":"<div class=\"admonition\">\n<details>\n<summary class=\"admonition-header\">Complete example <code>DFlow</code> module</summary>","category":"page"},{"location":"examples/abstractsource-subtypes/","page":"Defining AbstractSource subtypes","title":"Defining AbstractSource subtypes","text":"module DFlow\n\nusing DatasetManager, TextParse\n\nexport DFlowSource\n\nstruct DFlowSource <: AbstractSource\n    path::String\nend\n\nfunction DatasetManager.readsource(s::DFlowSource; kwargs...)\n    csvread(sourcepath(s); skiplines_begin=2, header_exists=false, kwargs...)\nend\n\nfunction DatasetManager.readsegment(seg::Segment{DFlowSource}; kwargs...)\n    columns, colnames = readsource(seg.source; kwargs...)\n    firsttime = first(columns[timecol])\n    lasttime = last(columns[timecol])\n\n    if isnothing(seg.finish)\n        _finish = lasttime\n    else\n        _finish = seg.finish\n    end\n\n    firsttime â‰¤ seg.start â‰¤ lasttime || throw(error(\"$s start time $(seg.start) is not within\"*\n        \"the source time range of $firsttime:$lasttime\"))\n    firsttime â‰¤ _finish â‰¤ lasttime || throw(error(\"$s finish time $(seg.finish) is not within \"*\n        \"the source time range of $firsttime:$lasttime\"))\n\n    startidx = searchsortedfirst(columns[timecol], firsttime)\n\n    if isnothing(seg.finish)\n        finidx = lastindex(columns[timecol])\n    else\n        finidx = searchsortedlast(columns[timecol], seg.finish)\n\n    end\n    segcolumns = ntuple(i -> columns[i][startidx:finidx], length(columns))\n\n    return segcolumns, colnames\nend\n\nend","category":"page"},{"location":"examples/abstractsource-subtypes/","page":"Defining AbstractSource subtypes","title":"Defining AbstractSource subtypes","text":"</details>\n</div>\n</p>","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = DatasetManager","category":"page"},{"location":"#DatasetManager","page":"Home","title":"DatasetManager","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DatasetManager was designed to solve several common problems when working with new datasets from human subjects research studies with the overall goal of reducing the amount of repetitive and custom code needed for new research.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The core functionality of DatasetManager eases the analysis of a new dataset by allowing the researcher to describe the dataset (e.g. the locations of the various sources or data, naming formats, etc) and then finding all the trials and associated metadata (e.g. subject identifier, trial conditions) in the dataset. Additional functionality includes the ability to define segments of the timeseries of a trial and attach experimental conditions specific to those segments, and a user-extensible common interface for reading/loading different sources of data using the correct method based on the type of data.","category":"page"},{"location":"#Common-issues-solved-by-DatasetManager","page":"Home","title":"Common issues solved by DatasetManager","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Most datasets have a unique organization and structure to how and where the data is stored on disk. Similarly, many datasets will use different naming schemes for trials and experimental conditions, based on the needs of the study and the preferences of the researcher. These unique aspects of each dataset require writing custom code to find and interpret the naming for every new dataset, which wastes valuable time the researcher could be spending developing analyses or interpreting results.\nThe findtrials function returns a list of every trial in the dataset when given a description of how and where the data is stored, paving the way for batch processing of the dataset.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Datasets often have more than one source of data per trial (e.g. if multiple systems were used to collect different kinds of data, such as EMG and motion capture). These different kinds of data require special code to load them for analysis. Furthermore, even within the same file extension (e.g. .csv), files can have different data organization (e.g. the number of lines in the header); these differences make the use of file extension to choose the loading function a less than optimal solution for loading various kinds of data.\nDatasetManager provides a simple interface where the researcher can specify the appropriate function for reading a particular type of data.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Oftentimes, the entirety of a trial may not be needed, such as if the first part of a trial isn't used, or if a trial contains multiple different experimental conditions applied at different intervals throughout the duration of the trial.\nSegments describe the specific interval (the start time and end time) within a given trial and any experimental conditions specific to that interval of time.","category":"page"},{"location":"#Limitations","page":"Home","title":"Limitations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The findtrials function currently requires all the desired trial metadata (e.g. subject identifier, experimental conditions, etc) to be present in the absolute path of every trial. The ability to find trial metadata in alternate formats or locations (e.g. trial metadata is stored in separate files) is a feature we plan to add in the future.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Different sources are collated into a single trial when the subject identifier and all experiemental conditions match. Duplicate trials (in terms of identical experimental conditions and subject ID) are not currently supported.","category":"page"},{"location":"","page":"Home","title":"Home","text":"Please open an issue if either of these limitations are a impediment to using DatasetManager.jl with your data, if you have a request for a feature that would be a good fit for this package, or if you have any issues using this package.","category":"page"},{"location":"julia-reference/#Julia-Reference","page":"Julia Reference","title":"Julia Reference","text":"","category":"section"},{"location":"julia-reference/#Sources","page":"Julia Reference","title":"Sources","text":"","category":"section"},{"location":"julia-reference/","page":"Julia Reference","title":"Julia Reference","text":"AbstractSource\nSource\nreadsource\nsourcepath\nrequiresource!\ngeneratesource\ndependencies\nDatasetManager.srcext\nDatasetManager.srcname_default","category":"page"},{"location":"julia-reference/#DatasetManager.AbstractSource","page":"Julia Reference","title":"DatasetManager.AbstractSource","text":"AbstractSource\n\nThe abstract supertype for custom data sources. Implement a subtype of AbstractSource if Source{S} is not sufficient for your source requirements (e.g. your source has additional information besides the path, such as encoding parameters, compression indicator, etc, that needs to be associated with each instance).\n\nExtended help\n\nAll subtypes of AbstractSource must:\n\nhave a path field or extend the sourcepath function.\naccept a single string, the absolute path of the source file, in the constructor.\n\nMinimum method definitions necessary for complete functionality of a subtype of AbstractSource (i.e. Source{S} or otherwise):\n\nreadsource\nsourcepath (if defining a new subtype of AbstractSource)\n\nAdditional methods to improve user experience and/or additional functionality\n\nreadsegment\ngeneratesource (if enabling requiresource! generation)\ndependencies (if defining a generatesource method)\nsrcext\nsrcname_default\n\nExample\n\nstruct MySource <: AbstractSource\n    path::String\nend\n\nDatasetManager.readsource(src::MySource) = customreadfunc(sourcepath(src))\nDatasetManager.readsegment(seg::Segment{MySource}) = readsource(seg.source)[start:finish]\n\n\n\n\n\n","category":"type"},{"location":"julia-reference/#DatasetManager.Source","page":"Julia Reference","title":"DatasetManager.Source","text":"Source{S}(path)\n\nA basic source, where S can be any singleton or existing type\n\n\n\n\n\n","category":"type"},{"location":"julia-reference/#DatasetManager.readsource","page":"Julia Reference","title":"DatasetManager.readsource","text":"readsource(src::S; kwargs...) where {S <: AbstractSource}\n\nRead the source data from file.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.sourcepath","page":"Julia Reference","title":"DatasetManager.sourcepath","text":"sourcepath(src) -> String\n\nReturn the absolute path to the src.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.requiresource!","page":"Julia Reference","title":"DatasetManager.requiresource!","text":"requiresource!(trial, src::Union{S,Type{S}}; force=false, deps, kwargs...) -> nothing\nrequiresource!(trial, name::String => src::Union{S,Type{S}}; force=false, deps, kwargs...)\n\nRequire a source src in trial, generate src if not present, or throw an error if src is not present and cannot be generated. Returns nothing. Keyword argument deps defaults to dependencies(src), but can be manually specified as a name => src::AbstractSource pair per dependency if there exist multiple sources that would match a dependent source type. kwargs... are passed on to the generatesource function for src.\n\nKeyword arguments\n\nforce=false: Force generating src, even if it already exists\ndeps=dependencies(src): Manually specify particular dependencies\n\nExamples\n\njulia> dependencies(Source{Events})\n(Source{C3DFile},)\n\njulia> requiresource!(trial, Source{Events})\n\njulia> requiresource!(trial, Source{Events}; force=true, deps=(\"mainc3d\" => Source{C3DFile}))\n\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.generatesource","page":"Julia Reference","title":"DatasetManager.generatesource","text":"generatesource(trial, src::Union{S,Type{S}}, deps; kwargs...) where S <: AbstractSource -> newsrc::typeof(src)\n\nGenerate source src using dependent sources deps from trial. Returns a source of the same type as src, but is not required to be exactly equal to src (i.e. a different sourcepath(newsrc) is acceptable).\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.dependencies","page":"Julia Reference","title":"DatasetManager.dependencies","text":"dependencies(src::Union{S,Type{S}})\n\nGet the sources that src depends on to be generated by generatesource.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.srcext","page":"Julia Reference","title":"DatasetManager.srcext","text":"srcext(src::Union{S,Type{S}})\n\nActual file extension or default file extension for a src or src type\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.srcname_default","page":"Julia Reference","title":"DatasetManager.srcname_default","text":"Default name for a source in Trial.sources\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#Trials","page":"Julia Reference","title":"Trials","text":"","category":"section"},{"location":"julia-reference/","page":"Julia Reference","title":"Julia Reference","text":"DataSubset\nTrialConditions\nTrial\nhassource\ngetsource\nsources\nfindtrials\nanalyzedataset\nexport_trials","category":"page"},{"location":"julia-reference/#DatasetManager.DataSubset","page":"Julia Reference","title":"DatasetManager.DataSubset","text":"DataSubset(name, source::Type{<:AbstractSource}, dir, pattern)\n\nDescribes a subset of data, where files found within dir, with (absolute) paths which match pattern (using glob syntax), are all of the same AbstractSource subtype.\n\nExamples\n\njulia> DataSubset(\"events\", Source{Events}, \"path/to/subset\", \"Subject [0-9]*/events/*.tsv\")\nDataSubset(\"events\", Source{Events}, \"path/to/subset\", \"Subject [0-9]*/events/*.tsv\")\n\n\n\n\n\n","category":"type"},{"location":"julia-reference/#DatasetManager.TrialConditions","page":"Julia Reference","title":"DatasetManager.TrialConditions","text":"TrialConditions(conditions, labels; <keyword arguments>)\n\nDescribes the experimental conditions and the labels for levels within each condition.\n\nArguments\n\nconditions is a collection of condition names (eg (:medication, :strength))\nlabels is a Dict with keys for each condition name (eg haskey(labels, :medication)).\n\nEach key gets a collection of the labels for all levels and any transformation desired for that condition.\n\nKeyword arguments\n\nrequired=conditions: The conditions which every trial must have (in the case of some\n\ntrials having optional/additional conditions).\n\ntypes=fill(String, length(conditions): The (Julia) types for each condition (eg\n\n[String, Int])\n\nsep=\"[_-]\": The character separating condition labels\n\n\n\n\n\n","category":"type"},{"location":"julia-reference/#DatasetManager.Trial","page":"Julia Reference","title":"DatasetManager.Trial","text":"Trial(subject, name, [conditions[, sources]])\n\nDescribes a single trial, including a reference to the subject, trial name, trial conditions, and relevant sources of data.\n\n\n\n\n\n","category":"type"},{"location":"julia-reference/#DatasetManager.hassource","page":"Julia Reference","title":"DatasetManager.hassource","text":"hassource(trial, src::Union{String,S<:AbstractSource}) -> Bool\n\nCheck if trial has a source with key or type src.\n\nExamples\n\njulia> hassource(trial, \"model\")\nfalse\n\njulia> hassource(trial, Source{Events})\ntrue\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.getsource","page":"Julia Reference","title":"DatasetManager.getsource","text":"getsource(trial, src::Union{String,Type{<:AbstractSource}}) -> <:AbstractSource\ngetsource(trial, name::String => src::Type{<:AbstractSource}) -> <:AbstractSource\n\nReturn a source from trial with key or type src. When the second argument is a pair, a source with key name will returned, or of type src if no source name is present.\n\nIf multiple sources of type src are present, the desired source must be accessed by name/key only or an error will be thrown.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.sources","page":"Julia Reference","title":"DatasetManager.sources","text":"sources(trial::Trial{ID}) -> Dict{String,AbstractSource}\n\nGet the sources for trial\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.findtrials","page":"Julia Reference","title":"DatasetManager.findtrials","text":"findtrials(subsets::AbstractVector{DataSubset}, conditions::TrialConditions;\n    <keyword arguments>) -> Vector{Trial}\n\nFind all the trials matching conditions which can be found in subsets.\n\nKeyword arguments:\n\nsubject_fmt=r\"(?<=Subject )(?<subject>\\d+)\": The format that the subject identifier  will appear in file paths.\nignorefiles::Union{Nothing, Vector{String}}=nothing: A list of files, given in the form  of an absolute path, that are in any of the subsets folders which are to be ignored.\ndefaultconds::Union{Nothing, Dict{Symbol}}=nothing: Any conditions which have a default  level if the condition is not found in the file path.\ndebug=false: Show Regex and files that did not match for each subset. Use to debug  TrialConditions definitions or issues with subject_fmt failing to match subject ID's.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.analyzedataset","page":"Julia Reference","title":"DatasetManager.analyzedataset","text":"analyzedataset(f, trials, Type{<:AbstractSource}; kwargs...) -> Vector{SegmentResult}\n\nCall function f on every trial in trials in parallel (multi-threaded). If f errors for a given trial, the SegmentResult for that trial will be empty (no results), and the trial and error will be shown after the analysis has finished.\n\nKeyword arguments\n\nthreaded=true: Analyze trials using multiple threads\nenable_progress=true: Enable the progress meter\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.export_trials","page":"Julia Reference","title":"DatasetManager.export_trials","text":"export_trials([f,] trials, dir[, sources])\n\nExport (copy) sources in trials to outdir. When left unspecified, sources is set to all unique sources found in trials. Optionally can be given a function f, which must accept 2 arguments (a trial and a src which is of eltype(sources)), to control the names of the exported data. The default behavior exports all sources to dir with no subdirectories, using the naming schema \"trialsubject_srcname_basename(sourcepath)\" (pseudo-code).\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#Segments","page":"Julia Reference","title":"Segments","text":"","category":"section"},{"location":"julia-reference/","page":"Julia Reference","title":"Julia Reference","text":"Segment\nSegmentResult\nreadsegment\ntrial\nsubject\nsegment\nsource\nconditions\nresults\nresultsvariables","category":"page"},{"location":"julia-reference/#DatasetManager.Segment","page":"Julia Reference","title":"DatasetManager.Segment","text":"Segment(trial, src::Union{S,Type{S},String}; [start, finish, conditions])\n\nDescribes a portion of a source in trial from time start to finish with segment specific conditions, if applicable.\n\nIf src is a String or AbstractSource, it must refer to a source that exists in trial. If the start is omitted, the segment will start at the beginning of the source/trial. If the finish is omitted, the segment will be from time start to the end of the source/trial.\n\nAny conditions present in trial will be merged into the conditions for the segment.\n\nExample:\n\nt = Trial(1, \"intervention\")\n\nstruct MySource <: AbstractSource\n    path::String\nend\n\nseg = Segment(t, MySource; start=0.0, finish=10.0, conditions=Dict(:group => \"control\"))\n\n# Use a source that already exists in the trial\nseg5 = Segment(t, \"main\")\n\n\n\n\n\n","category":"type"},{"location":"julia-reference/#DatasetManager.SegmentResult","page":"Julia Reference","title":"DatasetManager.SegmentResult","text":"SegmentResult(segment::Segment, results::Dict{Symbol)\n\nContains the results of any analysis/analyses performed on the trial segment in a Dict.\n\nExample:\n\nsegresult = SegmentResult(seg, Dict(:avg => 3.5))\n\n\n\n\n\n","category":"type"},{"location":"julia-reference/#DatasetManager.readsegment","page":"Julia Reference","title":"DatasetManager.readsegment","text":"readsegment(seg::Segment{S}; warn=true, kwargs...) where S <: AbstractSource\n\nIf defined for S, returns the portion of seg.source from seg.start to seg.finish. Otherwise, equivalent to readsource (i.e. no trimming of time-series occurs). Warns by default if the main method is called.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.trial","page":"Julia Reference","title":"DatasetManager.trial","text":"trial(seg::Union{Segment,SegmentResults}) -> Trial\n\nReturn the parent Trial for the given Segment or SegmentResult\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.subject","page":"Julia Reference","title":"DatasetManager.subject","text":"subject(trial::Trial{ID}) -> subject::ID\n\nGet the subject identifier for trial\n\n\n\n\n\nsubject(seg::Union{Segment,SegmentResults})\n\nReturn the subject reference for the parent Trial of the given Segment or SegmentResult\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.segment","page":"Julia Reference","title":"DatasetManager.segment","text":"Get the segment of a SegmentResult\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.source","page":"Julia Reference","title":"DatasetManager.source","text":"source(seg::Union{Segment,SegmentResults}) -> AbstractSource\n\nReturn the source for the parent Trial of the given Segment or SegmentResult\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.conditions","page":"Julia Reference","title":"DatasetManager.conditions","text":"conditions(trial::Trial{ID}) -> Dict{Symbol,Any}\n\nGet the conditions for trial\n\n\n\n\n\nconditions(seg::Union{Segment,SegmentResults}) -> Dict{Symbol}\n\nReturn the conditions for the given Segment or SegmentResult\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.results","page":"Julia Reference","title":"DatasetManager.results","text":"Get the results of a SegmentResult\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.resultsvariables","page":"Julia Reference","title":"DatasetManager.resultsvariables","text":"resultsvariables(sr::Union{SegmentResult,Vector{SegmentResult}})\n\nGet the unique variables for SegmentResults.\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#Utilities","page":"Julia Reference","title":"Utilities","text":"","category":"section"},{"location":"julia-reference/","page":"Julia Reference","title":"Julia Reference","text":"summarize\nDatasetManager.stack","category":"page"},{"location":"julia-reference/#DatasetManager.summarize","page":"Julia Reference","title":"DatasetManager.summarize","text":"summarize([io,] trials; verbosity=5)\n\nSummarize a vector of Trials.\n\nSummarizes:\n\nNumber of unique subjects and lists IDs\nTotal number of trials and trials per subject\nUnique conditions and observed levels, unique combinations of conditions\nUnique sources and source types\n\nExamples\n\njulia> summarize(trials)\nSubjects:\n â”” 15: 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15\nTrials:\n â”œ Number of trials: 90\n â”” Number of trials per subject:\n   â”” 6: 15/15 (100%)\nConditions:\n â”œ Observed levels:\n â”‚ â”œ sym => [\"asym\", \"sym\"]\n â”‚ â”” arms => [\"active\", \"held\", \"norm\"]\n â”” Unique level combinations observed: 6 (full factorial)\n      sym â”‚   arms â”‚ # trials\n    â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n     asym â”‚ active â”‚ 15\n     asym â”‚   held â”‚ 15\n     asym â”‚   norm â”‚ 15\n      sym â”‚ active â”‚ 15\n      â‹®   â”‚   â‹®    â”‚ â‹®\nSources:\n â”” \"events\" => Source{Events}, 90 trials (100%)\n\n\n\n\n\n\n","category":"function"},{"location":"julia-reference/#DatasetManager.stack","page":"Julia Reference","title":"DatasetManager.stack","text":"stack(rs::Vector{SegmentResult}, conds; [variables])\n\nCompile the results into a stacked, long form DataFrame\n\n\n\n\n\n","category":"function"}]
}
