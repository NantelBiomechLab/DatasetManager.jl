"""
    AbstractSource

The abstract supertype for custom data sources. Implement a subtype of `AbstractSource` if
`Source{S}` is not sufficient for your source requirements (e.g. your source has additional
information besides the path, such as encoding parameters, compression indicator, etc, that
needs to be associated with each instance).

# Extended help

All subtypes of `AbstractSource` **must**:

- have a `path` field or extend the `sourcepath` function.
- have an empty constructor
- have a constructor accepting a string (the absolute path of the source file) as the sole
  argument

Minimum method definitions necessary for complete functionality of a subtype of
`AbstractSource` (i.e. `Source{S}` or otherwise):
- [`readsource`](@ref)
- [`sourcepath`](@ref) (if defining a new subtype of `AbstractSource`)

Additional methods to improve user experience and/or additional functionality
- [`readsegment`](@ref)
- [`generatesource`](@ref) (if enabling `requiresource!` generation)
- [`dependencies`](@ref) (if defining a `generatesource` method)
- [`srcext`](@ref)
- [`srcname_default`](@ref)
"""
abstract type AbstractSource end

(::Type{S})() where S <: AbstractSource = S(tempname()*srcext(S))

"""
    Source{S}([path])

A standard/default source, where `S` can be an existing type or a singleton type defined for
dispatch purposes. When `path` is omitted, a unique temporary file path is used.

# Examples
```julia-repl
julia> Source{Missing}()
Source{Missing}("/tmp/jl_ruMeMy")

julia> struct RandomDev; end

julia> Source{RandomDev}("/dev/urandom")
Source{RandomDev}("/dev/urandom")
```
"""
struct Source{S} <: AbstractSource
    path::String
end

Source{S}() where S = Source{S}(tempname()*srcext(Source{S}))

"""
    sourcepath(src) -> String

Return the absolute path to the `src`.
"""
sourcepath(src::AbstractSource) = abspath(src.path::String)

"""
    srcext(src::Type{S}) where {S<:AbstractSource} -> String
    srcext(src::S) where {S<:AbstractSource} -> String

Return the file extension for `src`. If `src` is an `AbstractSource` subtype, the default
extension for that subtype will be returned; if `src` is an `AbstractSource` instance, the
returned extension will be the actual extension for that `src`, regardless of whether it is
the same as the default extension for that `src` type.

# Extended help

When extending this function for a custom source, only define a method for the source type,
e.g. `srcext(::Type{MySource})`. The period (.) should be included in the extension as the
first letter.
"""
srcext(src::AbstractSource) = splitext(sourcepath(src))[2]
srcext(::Type{<:AbstractSource}) = ""

"""
    readsource(src::S; kwargs...) where {S <: AbstractSource}

Read the source data from file.
"""
function readsource end

struct UnknownDeps end

"""
    dependencies(src::Union{S,Type{S}}) where {S<:AbstractSource} -> Tuple{<:AbstractSource}

Get the sources that `src` depends on to be generated by `generatesource`. Defaults to
`UnknownDeps`, which prevents automatically generating `src`.

# Extended help

In some cases, it may be preferable to leave the dependencies for an `AbstractSource`
subtype undefined if e.g. the source is a container of some form that may contain data
generated and depending an unknown number/type of sources.
"""
dependencies(::S) where S <: AbstractSource = dependencies(S)
dependencies(::Type{<:AbstractSource}) = UnknownDeps()

"""
    srcname_default(src::Union{S,Type{S}}) where {S<:AbstractSource} -> String

Get the default name for a source of type `S`
"""
srcname_default(::S) where S <: AbstractSource = srcname_default(S)
srcname_default(s) = string(s)

struct MissingSourceError <: Exception
    msg::String
end

function Base.showerror(io::IO, e::MissingSourceError)
    print(io, "MissingSourceError: ")
    print(io, e.msg)
end

"""
    requiresource!(trial, name::String; [force, deps, kwargs...]) -> nothing
    requiresource!(trial, name::Regex; <keyword arguments>) -> nothing
    requiresource!(trial, src::S; <keyword arguments>) where {S<:AbstractSource} -> nothing
    requiresource!(trial, ::Type{S}; <keyword arguments>) where {S<:AbstractSource} -> nothing
    requiresource!(trial, name::String => src; <keyword arguments>) -> nothing

Require `src` to be exist for `trial`. Generate `src` if it does not exist, or throw an
error if `src` is not present and cannot be generated. When `src` is a `Regex`, `deps` is
constrained to `UnknownDeps`, regardless of the keyword argument.

# Keyword arguments
- `force=false`: Force generating `src`, even if it already exists
- `deps=dependencies(src)`: `deps` can be manually specified as a
  `name => src::AbstractSource` pair per dependency if there exist multiple sources that
  would match a dependent source type. `kwargs...` are passed on to the `generatesource`
  function for `src`.

# Examples
```julia-repl
julia> dependencies(Source{Events})
(Source{C3DFile},)

julia> requiresource!(trial, Source{Events})

julia> requiresource!(trial, Source{Events}; force=true, deps=("mainc3d" => Source{C3DFile}))

```
"""
function requiresource!(trial, src::AbstractSource, parent=nothing; kwargs...)
    requiresource!(trial, srcname_default(src) => src, parent; kwargs...)
end

function requiresource!(trial, src::Type{<:AbstractSource}, parent=nothing; kwargs...)
    requiresource!(trial, srcname_default(src) => src(), parent; kwargs...)
end

function requiresource!(trial, name::Regex)
    requiresource!(trial, name => Source{Nothing}(""), nothing; force=false, deps=UnknownDeps())
end

function requiresource!(trial, namesrc::Pair, parent=nothing;
    force=false, deps=dependencies(namesrc.second), kwargs...
)
    name, src = namesrc
    if !force
        if (parent !== nothing && hassource(trial, typeof(src))) ||
            hassource(trial, name) || hassource(trial, src)
            return nothing
        elseif isfile(sourcepath(src))
            sources(trial)[name] = src
            return nothing
        end
    end

    if deps isa UnknownDeps
        # TODO: Cause/solution for `MissingSourceError` unclear from error name or message
        if force
            throw(MissingSourceError("unable to generate missing source $name => $src for $trial"))
        else
            throw(MissingSourceError("required source $name is missing for $trial"))
        end
    else
        foreach(deps) do reqsrc
            requiresource!(trial, reqsrc, src; force=false)
        end
    end
    _src = generatesource(trial, src, deps; kwargs...)
    isfile(sourcepath(_src)) ||
        throw(MissingSourceError("failed to generate source $name => $_src for $trial"))

    sources(trial)[name] = _src

    return nothing
end

"""
    generatesource(trial, src::Union{S,Type{S}}, deps; kwargs...) where S <: AbstractSource -> newsrc::typeof(src)

Generate source `src` using dependent sources `deps` from `trial`. Returns a source of the same
type as `src`, but is not required to be exactly equal to `src` (i.e. a different
`sourcepath(newsrc)` is acceptable).
"""
function generatesource end

generatesource(trial, ::Type{S}, deps; kwargs...) where S <: AbstractSource =
    generatesource(trial, S(), deps; kwargs...)

