(::Type{S})() where S <: AbstractSource = S(tempname()*srcext(S))

"""
    Source{S}([path])

A standard/default source, where `S` can be an existing type or a singleton type defined for
dispatch purposes. When `path` is omitted, a unique temporary file path is used.

# Examples
```julia-repl
julia> Source{Missing}()
Source{Missing}("/tmp/jl_ruMeMy")

julia> struct RandomDev; end

julia> Source{RandomDev}("/dev/urandom")
Source{RandomDev}("/dev/urandom")
```
"""
struct Source{S} <: AbstractSource
    path::String
end

Source{S}() where S = Source{S}(tempname()*srcext(Source{S}))

"""
    sourcepath(src) -> String

Return the absolute path to the `src`.
"""
sourcepath(src::AbstractSource) = abspath(src.path::String)

"""
    srcext(src::Type{S}) where {S<:AbstractSource} -> String
    srcext(src::S) where {S<:AbstractSource} -> String

Return the file extension for `src`. If `src` is an `AbstractSource` subtype, the default
extension for that subtype will be returned; if `src` is an `AbstractSource` instance, the
returned extension will be the actual extension for that `src`, regardless of whether it is
the same as the default extension for that `src` type.

# Extended help

When extending this function for a custom source, only define a method for the source type,
e.g. `srcext(::Type{MySource})`. The period (.) should be included in the extension as the
first letter.
"""
srcext(src::AbstractSource) = splitext(sourcepath(src))[2]
srcext(::Type{<:AbstractSource}) = ""

"""
    readsource(src::S; kwargs...) where {S <: AbstractSource}

Read the source data from file.
"""
function readsource end

struct UnknownDeps end

"""
    dependencies(src::Union{S,Type{S}}) where {S<:AbstractSource} -> Tuple{<:AbstractSource}

Get the sources that `src` depends on to be generated by `generatesource`. Defaults to
`UnknownDeps`, which prevents automatically generating `src`.

# Extended help

In some cases, it may be preferable to leave the dependencies for custom source undefined if
e.g. the source is a container of some form that may contain data generated and depending an
unknown number/type of sources.
"""
dependencies(::S) where S <: AbstractSource = dependencies(S)
dependencies(::Type{<:AbstractSource}) = UnknownDeps()

"""
    srcname_default(src::Union{S,Type{S}}) where {S<:AbstractSource} -> String

Get the default name for a source of type `S`
"""
srcname_default(::S) where S <: AbstractSource = srcname_default(S)
srcname_default(s) = string(s)

struct MissingSourceError <: Exception
    msg::String
end

function Base.showerror(io::IO, e::MissingSourceError)
    print(io, "MissingSourceError: ")
    print(io, e.msg)
end

"""
    requiresource!([generatesource::Function,] trial, name::String; <keyword args>) -> nothing
    requiresource!([generatesource::Function,] trial, name::Regex; <keyword args>) -> nothing
    requiresource!([generatesource::Function,] trial, src::{<:AbstractSource}; <keyword args>) -> nothing
    requiresource!([generatesource::Function,] trial, ::Type{<:AbstractSource}; <keyword args>) -> nothing
    requiresource!([generatesource::Function,] trial, name::String => src; <keyword args>) -> nothing

Require `src` to be exist for `trial`. Generate `src` if it does not exist, or throw an
error if `src` is not present and cannot be generated. When `src` is a `Regex`, `deps` is
constrained to `UnknownDeps`, regardless of the keyword argument. Unused keyword arguments
will be passed on to the `generatesource` method for `src`.

Typically, a specific `generatesource` method should be written for each custom
`AbstractSource` type, however, sometimes the `do` function syntax may be convenient. Note
the `do` syntax does not allow passing additional kwargs.

# Keyword arguments
- `force=false`: Force generating `src`, even if it already exists
- `deps=dependencies(src)`: `deps` can be manually specified as a
  `name => src::AbstractSource` pair per dependency if there exist multiple sources that
  would match a dependent source type. `kwargs...` are passed on to the `generatesource`
  function for `src`.

# Examples
```julia-repl
julia> dependencies(Source{Events})
(Source{C3DFile},)

julia> requiresource!(trial, Source{Events})

julia> requiresource!(trial, Source{Events}; force=true, deps=("mainc3d" => Source{C3DFile}))

```

See also: [`generatesource`](@ref)
"""
function requiresource!(
    generate::Function, trial::Trial, src::AbstractSource, parent=nothing; kwargs...
)
    requiresource!(generate, trial, srcname_default(src) => src, parent; kwargs...)
end

requiresource!(trial::Trial, src::AbstractSource, parent=nothing; kwargs...) =
    requiresource!(generatesource, src, parent; kwargs...)

function requiresource!(
    generate::Function, trial::Trial, src::Type{<:AbstractSource}, parent=nothing; kwargs...
)
    requiresource!(generate, trial, srcname_default(src) => src(), parent; kwargs...)
end

requiresource!(trial::Trial, src::Type{<:AbstractSource}, parent=nothing; kwargs...) =
    requiresource!(generatesource, trial, src::Type{<:AbstractSource}, parent=nothing; kwargs...)

function requiresource!(generate::Function, trial::Trial, name::Regex)
    requiresource!(generatesource, trial, name => Source{Nothing}(""), nothing;
        force=false, deps=UnknownDeps())
end

requiresource!(trial::Trial, name::Regex) = requiresource!(generatesource, trial, name::Regex)

requiresource!(trial::Trial, namesrc::Pair, parent=nothing; kwargs...) =
    requiresource!(generatesource, trial, namesrc, parent; kwargs...)

function requiresource!(generate::Function, trial::Trial, namesrc::Pair, parent=nothing;
    force=false, deps=dependencies(namesrc.second), kwargs...
)
    name, src = namesrc
    if !force
        if (parent !== nothing && hassource(trial, typeof(src))) ||
            hassource(trial, name) || hassource(trial, src)
            return nothing
        elseif isfile(sourcepath(src))
            sources(trial)[name] = src
            return nothing
        end
    end

    if deps isa UnknownDeps
        # TODO: Cause/solution for `MissingSourceError` unclear from error name or message
        if force
            throw(MissingSourceError("unable to generate missing source $name => $src for $trial"))
        else
            throw(MissingSourceError("required source $name is missing for $trial"))
        end
    else
        foreach(deps) do reqsrc
            requiresource!(generate, trial, reqsrc, src; force=false)
        end
    end
    _src = generate(trial, src, deps; kwargs...)
    isfile(sourcepath(_src)) ||
        throw(MissingSourceError("failed to generate source $name => $_src for $trial"))

    sources(trial)[name] = _src

    return nothing
end

"""
    generatesource(trial, src::Union{S,Type{S}}, deps; kwargs...) where S <: AbstractSource -> newsrc::typeof(src)

Generate source `src` using dependent sources `deps` from `trial`. Returns a source of the same
type as `src`, but is not required to be exactly equal to `src` (i.e. a different
`sourcepath(newsrc)` is acceptable). Keyword arguments named `force` and `deps` should not
be used in `generatesource` methods since they are used in `requiresource!` and will not be
passed on to the `generatesource` method.
"""
function generatesource end

generatesource(trial, ::Type{S}, deps; kwargs...) where S <: AbstractSource =
    generatesource(trial, S(), deps; kwargs...)

